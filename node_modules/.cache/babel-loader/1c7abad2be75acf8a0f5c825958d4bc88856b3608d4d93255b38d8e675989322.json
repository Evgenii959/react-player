{"ast":null,"code":"export { createEmptyActor, fromCallback, fromEventObservable, fromObservable, fromPromise, fromTransition } from '../actors/dist/xstate-actors.esm.js';\nimport { t as toArray, S as STATE_DELIMITER, m as mapValues, f as formatTransitions, a as toTransitionConfigArray, b as formatTransition, N as NULL_EVENT, e as evaluateGuard, c as createInvokeId, g as getDelayedTransitions, d as formatInitialTransition, h as getCandidates, r as resolveStateValue, i as getAllStateNodes, j as getStateNodes, k as createMachineSnapshot, l as isInFinalState, n as macrostep, o as transitionNode, p as resolveActionsAndContext, q as createInitEvent, s as microstep, u as getInitialStateNodes, v as toStatePath, w as isStateId, x as getStateNodeByPath, y as getPersistedSnapshot, z as resolveReferencedActor, A as createActor, $ as $$ACTOR_TYPE } from './raise-0f7cf128.esm.js';\nexport { B as Actor, I as __unsafe_getAllOwnEventDescriptors, D as and, M as cancel, A as createActor, j as getStateNodes, C as interpret, H as isMachineSnapshot, J as matchesState, E as not, F as or, K as pathToStateValue, O as raise, P as spawnChild, G as stateIn, Q as stop, R as stopChild, L as toObserver } from './raise-0f7cf128.esm.js';\nimport { a as assign } from './log-15d0f775.esm.js';\nexport { S as SpecialTargets, a as assign, e as emit, b as enqueueActions, f as forwardTo, l as log, s as sendParent, c as sendTo } from './log-15d0f775.esm.js';\nimport '../dev/dist/xstate-dev.esm.js';\n\n/**\n * Asserts that the given event object is of the specified type or types. Throws\n * an error if the event object is not of the specified types.\n *\n * @example\n *\n * ```ts\n * // ...\n * entry: ({ event }) => {\n *   assertEvent(event, 'doNothing');\n *   // event is { type: 'doNothing' }\n * },\n * // ...\n * exit: ({ event }) => {\n *   assertEvent(event, 'greet');\n *   // event is { type: 'greet'; message: string }\n *\n *   assertEvent(event, ['greet', 'notify']);\n *   // event is { type: 'greet'; message: string }\n *   // or { type: 'notify'; message: string; level: 'info' | 'error' }\n * },\n * ```\n */\nfunction assertEvent(event, type) {\n  const types = toArray(type);\n  if (!types.includes(event.type)) {\n    const typesText = types.length === 1 ? `type \"${types[0]}\"` : `one of types \"${types.join('\", \"')}\"`;\n    throw new Error(`Expected event ${JSON.stringify(event)} to have ${typesText}`);\n  }\n}\nconst cache = new WeakMap();\nfunction memo(object, key, fn) {\n  let memoizedData = cache.get(object);\n  if (!memoizedData) {\n    memoizedData = {\n      [key]: fn()\n    };\n    cache.set(object, memoizedData);\n  } else if (!(key in memoizedData)) {\n    memoizedData[key] = fn();\n  }\n  return memoizedData[key];\n}\nconst EMPTY_OBJECT = {};\nconst toSerializableAction = action => {\n  if (typeof action === 'string') {\n    return {\n      type: action\n    };\n  }\n  if (typeof action === 'function') {\n    if ('resolve' in action) {\n      return {\n        type: action.type\n      };\n    }\n    return {\n      type: action.name\n    };\n  }\n  return action;\n};\nclass StateNode {\n  constructor(/** The raw config used to create the machine. */\n  config, options) {\n    this.config = config;\n    /**\n     * The relative key of the state node, which represents its location in the\n     * overall state value.\n     */\n    this.key = void 0;\n    /** The unique ID of the state node. */\n    this.id = void 0;\n    /**\n     * The type of this state node:\n     *\n     * - `'atomic'` - no child state nodes\n     * - `'compound'` - nested child state nodes (XOR)\n     * - `'parallel'` - orthogonal nested child state nodes (AND)\n     * - `'history'` - history state node\n     * - `'final'` - final state node\n     */\n    this.type = void 0;\n    /** The string path from the root machine node to this node. */\n    this.path = void 0;\n    /** The child state nodes. */\n    this.states = void 0;\n    /**\n     * The type of history on this state node. Can be:\n     *\n     * - `'shallow'` - recalls only top-level historical state value\n     * - `'deep'` - recalls historical state value at all levels\n     */\n    this.history = void 0;\n    /** The action(s) to be executed upon entering the state node. */\n    this.entry = void 0;\n    /** The action(s) to be executed upon exiting the state node. */\n    this.exit = void 0;\n    /** The parent state node. */\n    this.parent = void 0;\n    /** The root machine node. */\n    this.machine = void 0;\n    /**\n     * The meta data associated with this state node, which will be returned in\n     * State instances.\n     */\n    this.meta = void 0;\n    /**\n     * The output data sent with the \"xstate.done.state._id_\" event if this is a\n     * final state node.\n     */\n    this.output = void 0;\n    /**\n     * The order this state node appears. Corresponds to the implicit document\n     * order.\n     */\n    this.order = -1;\n    this.description = void 0;\n    this.tags = [];\n    this.transitions = void 0;\n    this.always = void 0;\n    this.parent = options._parent;\n    this.key = options._key;\n    this.machine = options._machine;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.id = this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER);\n    this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');\n    this.description = this.config.description;\n    this.order = this.machine.idMap.size;\n    this.machine.idMap.set(this.id, this);\n    this.states = this.config.states ? mapValues(this.config.states, (stateConfig, key) => {\n      const stateNode = new StateNode(stateConfig, {\n        _parent: this,\n        _key: key,\n        _machine: this.machine\n      });\n      return stateNode;\n    }) : EMPTY_OBJECT;\n    if (this.type === 'compound' && !this.config.initial) {\n      throw new Error(`No initial state specified for compound state node \"#${this.id}\". Try adding { initial: \"${Object.keys(this.states)[0]}\" } to the state config.`);\n    }\n\n    // History config\n    this.history = this.config.history === true ? 'shallow' : this.config.history || false;\n    this.entry = toArray(this.config.entry).slice();\n    this.exit = toArray(this.config.exit).slice();\n    this.meta = this.config.meta;\n    this.output = this.type === 'final' || !this.parent ? this.config.output : undefined;\n    this.tags = toArray(config.tags).slice();\n  }\n\n  /** @internal */\n  _initialize() {\n    this.transitions = formatTransitions(this);\n    if (this.config.always) {\n      this.always = toTransitionConfigArray(this.config.always).map(t => formatTransition(this, NULL_EVENT, t));\n    }\n    Object.keys(this.states).forEach(key => {\n      this.states[key]._initialize();\n    });\n  }\n\n  /** The well-structured state node definition. */\n  get definition() {\n    return {\n      id: this.id,\n      key: this.key,\n      version: this.machine.version,\n      type: this.type,\n      initial: this.initial ? {\n        target: this.initial.target,\n        source: this,\n        actions: this.initial.actions.map(toSerializableAction),\n        eventType: null,\n        reenter: false,\n        toJSON: () => ({\n          target: this.initial.target.map(t => `#${t.id}`),\n          source: `#${this.id}`,\n          actions: this.initial.actions.map(toSerializableAction),\n          eventType: null\n        })\n      } : undefined,\n      history: this.history,\n      states: mapValues(this.states, state => {\n        return state.definition;\n      }),\n      on: this.on,\n      transitions: [...this.transitions.values()].flat().map(t => ({\n        ...t,\n        actions: t.actions.map(toSerializableAction)\n      })),\n      entry: this.entry.map(toSerializableAction),\n      exit: this.exit.map(toSerializableAction),\n      meta: this.meta,\n      order: this.order || -1,\n      output: this.output,\n      invoke: this.invoke,\n      description: this.description,\n      tags: this.tags\n    };\n  }\n\n  /** @internal */\n  toJSON() {\n    return this.definition;\n  }\n\n  /** The logic invoked as actors by this state node. */\n  get invoke() {\n    return memo(this, 'invoke', () => toArray(this.config.invoke).map((invokeConfig, i) => {\n      const {\n        src,\n        systemId\n      } = invokeConfig;\n      const resolvedId = invokeConfig.id ?? createInvokeId(this.id, i);\n      const resolvedSrc = typeof src === 'string' ? src : `xstate.invoke.${createInvokeId(this.id, i)}`;\n      return {\n        ...invokeConfig,\n        src: resolvedSrc,\n        id: resolvedId,\n        systemId: systemId,\n        toJSON() {\n          const {\n            onDone,\n            onError,\n            ...invokeDefValues\n          } = invokeConfig;\n          return {\n            ...invokeDefValues,\n            type: 'xstate.invoke',\n            src: resolvedSrc,\n            id: resolvedId\n          };\n        }\n      };\n    }));\n  }\n\n  /** The mapping of events to transitions. */\n  get on() {\n    return memo(this, 'on', () => {\n      const transitions = this.transitions;\n      return [...transitions].flatMap(_ref => {\n        let [descriptor, t] = _ref;\n        return t.map(t => [descriptor, t]);\n      }).reduce((map, _ref2) => {\n        let [descriptor, transition] = _ref2;\n        map[descriptor] = map[descriptor] || [];\n        map[descriptor].push(transition);\n        return map;\n      }, {});\n    });\n  }\n  get after() {\n    return memo(this, 'delayedTransitions', () => getDelayedTransitions(this));\n  }\n  get initial() {\n    return memo(this, 'initial', () => formatInitialTransition(this, this.config.initial));\n  }\n\n  /** @internal */\n  next(snapshot, event) {\n    const eventType = event.type;\n    const actions = [];\n    let selectedTransition;\n    const candidates = memo(this, `candidates-${eventType}`, () => getCandidates(this, eventType));\n    for (const candidate of candidates) {\n      const {\n        guard\n      } = candidate;\n      const resolvedContext = snapshot.context;\n      let guardPassed = false;\n      try {\n        guardPassed = !guard || evaluateGuard(guard, resolvedContext, event, snapshot);\n      } catch (err) {\n        const guardType = typeof guard === 'string' ? guard : typeof guard === 'object' ? guard.type : undefined;\n        throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ''}in transition for event '${eventType}' in state node '${this.id}':\\n${err.message}`);\n      }\n      if (guardPassed) {\n        actions.push(...candidate.actions);\n        selectedTransition = candidate;\n        break;\n      }\n    }\n    return selectedTransition ? [selectedTransition] : undefined;\n  }\n\n  /** All the event types accepted by this state node and its descendants. */\n  get events() {\n    return memo(this, 'events', () => {\n      const {\n        states\n      } = this;\n      const events = new Set(this.ownEvents);\n      if (states) {\n        for (const stateId of Object.keys(states)) {\n          const state = states[stateId];\n          if (state.states) {\n            for (const event of state.events) {\n              events.add(`${event}`);\n            }\n          }\n        }\n      }\n      return Array.from(events);\n    });\n  }\n\n  /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */\n  get ownEvents() {\n    const events = new Set([...this.transitions.keys()].filter(descriptor => {\n      return this.transitions.get(descriptor).some(transition => !(!transition.target && !transition.actions.length && !transition.reenter));\n    }));\n    return Array.from(events);\n  }\n}\nconst STATE_IDENTIFIER = '#';\nclass StateMachine {\n  constructor(/** The raw config used to create the machine. */\n  config, implementations) {\n    this.config = config;\n    /** The machine's own version. */\n    this.version = void 0;\n    this.schemas = void 0;\n    this.implementations = void 0;\n    /** @internal */\n    this.__xstatenode = true;\n    /** @internal */\n    this.idMap = new Map();\n    this.root = void 0;\n    this.id = void 0;\n    this.states = void 0;\n    this.events = void 0;\n    this.id = config.id || '(machine)';\n    this.implementations = {\n      actors: implementations?.actors ?? {},\n      actions: implementations?.actions ?? {},\n      delays: implementations?.delays ?? {},\n      guards: implementations?.guards ?? {}\n    };\n    this.version = this.config.version;\n    this.schemas = this.config.schemas;\n    this.transition = this.transition.bind(this);\n    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n    this.restoreSnapshot = this.restoreSnapshot.bind(this);\n    this.start = this.start.bind(this);\n    this.root = new StateNode(config, {\n      _key: this.id,\n      _machine: this\n    });\n    this.root._initialize();\n    this.states = this.root.states; // TODO: remove!\n    this.events = this.root.events;\n  }\n\n  /**\n   * Clones this state machine with the provided implementations and merges the\n   * `context` (if provided).\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`,\n   *   `context`) to recursively merge with the existing options.\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */\n  provide(implementations) {\n    const {\n      actions,\n      guards,\n      actors,\n      delays\n    } = this.implementations;\n    return new StateMachine(this.config, {\n      actions: {\n        ...actions,\n        ...implementations.actions\n      },\n      guards: {\n        ...guards,\n        ...implementations.guards\n      },\n      actors: {\n        ...actors,\n        ...implementations.actors\n      },\n      delays: {\n        ...delays,\n        ...implementations.delays\n      }\n    });\n  }\n  resolveState(config) {\n    const resolvedStateValue = resolveStateValue(this.root, config.value);\n    const nodeSet = getAllStateNodes(getStateNodes(this.root, resolvedStateValue));\n    return createMachineSnapshot({\n      _nodes: [...nodeSet],\n      context: config.context || {},\n      children: {},\n      status: isInFinalState(nodeSet, this.root) ? 'done' : config.status || 'active',\n      output: config.output,\n      error: config.error,\n      historyValue: config.historyValue\n    }, this);\n  }\n\n  /**\n   * Determines the next snapshot given the current `snapshot` and received\n   * `event`. Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */\n  transition(snapshot, event, actorScope) {\n    return macrostep(snapshot, event, actorScope).snapshot;\n  }\n\n  /**\n   * Determines the next state given the current `state` and `event`. Calculates\n   * a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */\n  microstep(snapshot, event, actorScope) {\n    return macrostep(snapshot, event, actorScope).microstates;\n  }\n  getTransitionData(snapshot, event) {\n    return transitionNode(this.root, snapshot.value, snapshot, event) || [];\n  }\n\n  /**\n   * The initial state _before_ evaluating any microsteps. This \"pre-initial\"\n   * state is provided to initial actions executed in the initial state.\n   */\n  getPreInitialState(actorScope, initEvent, internalQueue) {\n    const {\n      context\n    } = this.config;\n    const preInitial = createMachineSnapshot({\n      context: typeof context !== 'function' && context ? context : {},\n      _nodes: [this.root],\n      children: {},\n      status: 'active'\n    }, this);\n    if (typeof context === 'function') {\n      const assignment = _ref3 => {\n        let {\n          spawn,\n          event,\n          self\n        } = _ref3;\n        return context({\n          spawn,\n          input: event.input,\n          self\n        });\n      };\n      return resolveActionsAndContext(preInitial, initEvent, actorScope, [assign(assignment)], internalQueue);\n    }\n    return preInitial;\n  }\n\n  /**\n   * Returns the initial `State` instance, with reference to `self` as an\n   * `ActorRef`.\n   */\n  getInitialSnapshot(actorScope, input) {\n    const initEvent = createInitEvent(input); // TODO: fix;\n    const internalQueue = [];\n    const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);\n    const nextState = microstep([{\n      target: [...getInitialStateNodes(this.root)],\n      source: this.root,\n      reenter: true,\n      actions: [],\n      eventType: null,\n      toJSON: null // TODO: fix\n    }], preInitialState, actorScope, initEvent, true, internalQueue);\n    const {\n      snapshot: macroState\n    } = macrostep(nextState, initEvent, actorScope, internalQueue);\n    return macroState;\n  }\n  start(snapshot) {\n    Object.values(snapshot.children).forEach(child => {\n      if (child.getSnapshot().status === 'active') {\n        child.start();\n      }\n    });\n  }\n  getStateNodeById(stateId) {\n    const fullPath = toStatePath(stateId);\n    const relativePath = fullPath.slice(1);\n    const resolvedStateId = isStateId(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];\n    const stateNode = this.idMap.get(resolvedStateId);\n    if (!stateNode) {\n      throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);\n    }\n    return getStateNodeByPath(stateNode, relativePath);\n  }\n  get definition() {\n    return this.root.definition;\n  }\n  toJSON() {\n    return this.definition;\n  }\n  getPersistedSnapshot(snapshot, options) {\n    return getPersistedSnapshot(snapshot, options);\n  }\n  restoreSnapshot(snapshot, _actorScope) {\n    const children = {};\n    const snapshotChildren = snapshot.children;\n    Object.keys(snapshotChildren).forEach(actorId => {\n      const actorData = snapshotChildren[actorId];\n      const childState = actorData.snapshot;\n      const src = actorData.src;\n      const logic = typeof src === 'string' ? resolveReferencedActor(this, src) : src;\n      if (!logic) {\n        return;\n      }\n      const actorRef = createActor(logic, {\n        id: actorId,\n        parent: _actorScope.self,\n        syncSnapshot: actorData.syncSnapshot,\n        snapshot: childState,\n        src,\n        systemId: actorData.systemId\n      });\n      children[actorId] = actorRef;\n    });\n    const restoredSnapshot = createMachineSnapshot({\n      ...snapshot,\n      children,\n      _nodes: Array.from(getAllStateNodes(getStateNodes(this.root, snapshot.value)))\n    }, this);\n    let seen = new Set();\n    function reviveContext(contextPart, children) {\n      if (seen.has(contextPart)) {\n        return;\n      }\n      seen.add(contextPart);\n      for (let key in contextPart) {\n        const value = contextPart[key];\n        if (value && typeof value === 'object') {\n          if ('xstate$$type' in value && value.xstate$$type === $$ACTOR_TYPE) {\n            contextPart[key] = children[value.id];\n            continue;\n          }\n          reviveContext(value, children);\n        }\n      }\n    }\n    reviveContext(restoredSnapshot.context, children);\n    return restoredSnapshot;\n  }\n}\n\n// this is not 100% accurate since we can't make parallel regions required in the result\n// `TTestValue` doesn't encode this information anyhow for us to be able to do that\n// this is fine for most practical use cases anyway though\n\n/**\n * Creates a state machine (statechart) with the given configuration.\n *\n * The state machine represents the pure logic of a state machine actor.\n *\n * @example\n *\n * ```ts\n * import { createMachine } from 'xstate';\n *\n * const lightMachine = createMachine({\n *   id: 'light',\n *   initial: 'green',\n *   states: {\n *     green: {\n *       on: {\n *         TIMER: { target: 'yellow' }\n *       }\n *     },\n *     yellow: {\n *       on: {\n *         TIMER: { target: 'red' }\n *       }\n *     },\n *     red: {\n *       on: {\n *         TIMER: { target: 'green' }\n *       }\n *     }\n *   }\n * });\n *\n * const lightActor = createActor(lightMachine);\n * lightActor.start();\n *\n * lightActor.send({ type: 'TIMER' });\n * ```\n *\n * @param config The state machine configuration.\n * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })`\n *   to provide machine implementations instead.\n */\nfunction createMachine(config, implementations) {\n  return new StateMachine(config, implementations);\n}\n\n/** @internal */\nfunction createInertActorScope(actorLogic) {\n  const self = createActor(actorLogic);\n  const inertActorScope = {\n    self,\n    defer: () => {},\n    id: '',\n    logger: () => {},\n    sessionId: '',\n    stopChild: () => {},\n    system: self.system,\n    emit: () => {}\n  };\n  return inertActorScope;\n}\nfunction getInitialSnapshot(actorLogic) {\n  for (var _len = arguments.length, _ref4 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    _ref4[_key - 1] = arguments[_key];\n  }\n  let [input] = _ref4;\n  const actorScope = createInertActorScope(actorLogic);\n  return actorLogic.getInitialSnapshot(actorScope, input);\n}\n\n/**\n * Determines the next snapshot for the given `actorLogic` based on the given\n * `snapshot` and `event`.\n *\n * If the `snapshot` is `undefined`, the initial snapshot of the `actorLogic` is\n * used.\n *\n * @example\n *\n * ```ts\n * import { getNextSnapshot } from 'xstate';\n * import { trafficLightMachine } from './trafficLightMachine.ts';\n *\n * const nextSnapshot = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   undefined, // snapshot (or initial state if undefined)\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot.value);\n * // => 'yellow'\n *\n * const nextSnapshot2 = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   nextSnapshot, // snapshot\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot2.value);\n * // =>'red'\n * ```\n */\nfunction getNextSnapshot(actorLogic, snapshot, event) {\n  const inertActorScope = createInertActorScope(actorLogic);\n  inertActorScope.self._snapshot = snapshot;\n  return actorLogic.transition(snapshot, event, inertActorScope);\n}\n\n// at the moment we allow extra actors - ones that are not specified by `children`\n// this could be reconsidered in the future\n\nfunction setup(_ref5) {\n  let {\n    schemas,\n    actors,\n    actions,\n    guards,\n    delays\n  } = _ref5;\n  return {\n    createMachine: config => createMachine({\n      ...config,\n      schemas\n    }, {\n      actors,\n      actions,\n      guards,\n      delays\n    })\n  };\n}\nclass SimulatedClock {\n  constructor() {\n    this.timeouts = new Map();\n    this._now = 0;\n    this._id = 0;\n    this._flushing = false;\n    this._flushingInvalidated = false;\n  }\n  now() {\n    return this._now;\n  }\n  getId() {\n    return this._id++;\n  }\n  setTimeout(fn, timeout) {\n    this._flushingInvalidated = this._flushing;\n    const id = this.getId();\n    this.timeouts.set(id, {\n      start: this.now(),\n      timeout,\n      fn\n    });\n    return id;\n  }\n  clearTimeout(id) {\n    this._flushingInvalidated = this._flushing;\n    this.timeouts.delete(id);\n  }\n  set(time) {\n    if (this._now > time) {\n      throw new Error('Unable to travel back in time');\n    }\n    this._now = time;\n    this.flushTimeouts();\n  }\n  flushTimeouts() {\n    if (this._flushing) {\n      this._flushingInvalidated = true;\n      return;\n    }\n    this._flushing = true;\n    const sorted = [...this.timeouts].sort((_ref6, _ref7) => {\n      let [_idA, timeoutA] = _ref6;\n      let [_idB, timeoutB] = _ref7;\n      const endA = timeoutA.start + timeoutA.timeout;\n      const endB = timeoutB.start + timeoutB.timeout;\n      return endB > endA ? -1 : 1;\n    });\n    for (const [id, timeout] of sorted) {\n      if (this._flushingInvalidated) {\n        this._flushingInvalidated = false;\n        this._flushing = false;\n        this.flushTimeouts();\n        return;\n      }\n      if (this.now() - timeout.start >= timeout.timeout) {\n        this.timeouts.delete(id);\n        timeout.fn.call(null);\n      }\n    }\n    this._flushing = false;\n  }\n  increment(ms) {\n    this._now += ms;\n    this.flushTimeouts();\n  }\n}\n\n/**\n * Returns a promise that resolves to the `output` of the actor when it is done.\n *\n * @example\n *\n * ```ts\n * const machine = createMachine({\n *   // ...\n *   output: {\n *     count: 42\n *   }\n * });\n *\n * const actor = createActor(machine);\n *\n * actor.start();\n *\n * const output = await toPromise(actor);\n *\n * console.log(output);\n * // logs { count: 42 }\n * ```\n */\nfunction toPromise(actor) {\n  return new Promise((resolve, reject) => {\n    actor.subscribe({\n      complete: () => {\n        resolve(actor.getSnapshot().output);\n      },\n      error: reject\n    });\n  });\n}\nconst defaultWaitForOptions = {\n  timeout: Infinity // much more than 10 seconds\n};\n\n/**\n * Subscribes to an actor ref and waits for its emitted value to satisfy a\n * predicate, and then resolves with that value. Will throw if the desired state\n * is not reached after an optional timeout. (defaults to Infinity).\n *\n * @example\n *\n * ```js\n * const state = await waitFor(someService, (state) => {\n *   return state.hasTag('loaded');\n * });\n *\n * state.hasTag('loaded'); // true\n * ```\n *\n * @param actorRef The actor ref to subscribe to\n * @param predicate Determines if a value matches the condition to wait for\n * @param options\n * @returns A promise that eventually resolves to the emitted value that matches\n *   the condition\n */\nfunction waitFor(actorRef, predicate, options) {\n  const resolvedOptions = {\n    ...defaultWaitForOptions,\n    ...options\n  };\n  return new Promise((res, rej) => {\n    const {\n      signal\n    } = resolvedOptions;\n    if (signal?.aborted) {\n      rej(signal.reason);\n      return;\n    }\n    let done = false;\n    const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(() => {\n      dispose();\n      rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));\n    }, resolvedOptions.timeout);\n    const dispose = () => {\n      clearTimeout(handle);\n      done = true;\n      sub?.unsubscribe();\n      if (abortListener) {\n        signal.removeEventListener('abort', abortListener);\n      }\n    };\n    function checkEmitted(emitted) {\n      if (predicate(emitted)) {\n        dispose();\n        res(emitted);\n      }\n    }\n\n    /**\n     * If the `signal` option is provided, this will be the listener for its\n     * `abort` event\n     */\n    let abortListener;\n    let sub; // avoid TDZ when disposing synchronously\n\n    // See if the current snapshot already matches the predicate\n    checkEmitted(actorRef.getSnapshot());\n    if (done) {\n      return;\n    }\n\n    // only define the `abortListener` if the `signal` option is provided\n    if (signal) {\n      abortListener = () => {\n        dispose();\n        // XState does not \"own\" the signal, so we should reject with its reason (if any)\n        rej(signal.reason);\n      };\n      signal.addEventListener('abort', abortListener);\n    }\n    sub = actorRef.subscribe({\n      next: checkEmitted,\n      error: err => {\n        dispose();\n        rej(err);\n      },\n      complete: () => {\n        dispose();\n        rej(new Error(`Actor terminated without satisfying predicate`));\n      }\n    });\n    if (done) {\n      sub.unsubscribe();\n    }\n  });\n}\nexport { SimulatedClock, StateMachine, StateNode, assertEvent, createMachine, getInitialSnapshot, getNextSnapshot, setup, toPromise, waitFor };","map":{"version":3,"names":["createEmptyActor","fromCallback","fromEventObservable","fromObservable","fromPromise","fromTransition","t","toArray","S","STATE_DELIMITER","m","mapValues","f","formatTransitions","a","toTransitionConfigArray","b","formatTransition","N","NULL_EVENT","e","evaluateGuard","c","createInvokeId","g","getDelayedTransitions","d","formatInitialTransition","h","getCandidates","r","resolveStateValue","i","getAllStateNodes","j","getStateNodes","k","createMachineSnapshot","l","isInFinalState","n","macrostep","o","transitionNode","p","resolveActionsAndContext","q","createInitEvent","s","microstep","u","getInitialStateNodes","v","toStatePath","w","isStateId","x","getStateNodeByPath","y","getPersistedSnapshot","z","resolveReferencedActor","A","createActor","$","$$ACTOR_TYPE","B","Actor","I","__unsafe_getAllOwnEventDescriptors","D","and","M","cancel","C","interpret","H","isMachineSnapshot","J","matchesState","E","not","F","or","K","pathToStateValue","O","raise","P","spawnChild","G","stateIn","Q","stop","R","stopChild","L","toObserver","assign","SpecialTargets","emit","enqueueActions","forwardTo","log","sendParent","sendTo","assertEvent","event","type","types","includes","typesText","length","join","Error","JSON","stringify","cache","WeakMap","memo","object","key","fn","memoizedData","get","set","EMPTY_OBJECT","toSerializableAction","action","name","StateNode","constructor","config","options","id","path","states","history","entry","exit","parent","machine","meta","output","order","description","tags","transitions","always","_parent","_key","_machine","concat","Object","keys","idMap","size","stateConfig","stateNode","initial","slice","undefined","_initialize","map","forEach","definition","version","target","source","actions","eventType","reenter","toJSON","state","on","values","flat","invoke","invokeConfig","src","systemId","resolvedId","resolvedSrc","onDone","onError","invokeDefValues","flatMap","_ref","descriptor","reduce","_ref2","transition","push","after","next","snapshot","selectedTransition","candidates","candidate","guard","resolvedContext","context","guardPassed","err","guardType","message","events","Set","ownEvents","stateId","add","Array","from","filter","some","STATE_IDENTIFIER","StateMachine","implementations","schemas","__xstatenode","Map","root","actors","delays","guards","bind","getInitialSnapshot","restoreSnapshot","start","provide","resolveState","resolvedStateValue","value","nodeSet","_nodes","children","status","error","historyValue","actorScope","microstates","getTransitionData","getPreInitialState","initEvent","internalQueue","preInitial","assignment","_ref3","spawn","self","input","preInitialState","nextState","macroState","child","getSnapshot","getStateNodeById","fullPath","relativePath","resolvedStateId","_actorScope","snapshotChildren","actorId","actorData","childState","logic","actorRef","syncSnapshot","restoredSnapshot","seen","reviveContext","contextPart","has","xstate$$type","createMachine","createInertActorScope","actorLogic","inertActorScope","defer","logger","sessionId","system","_len","arguments","_ref4","getNextSnapshot","_snapshot","setup","_ref5","SimulatedClock","timeouts","_now","_id","_flushing","_flushingInvalidated","now","getId","setTimeout","timeout","clearTimeout","delete","time","flushTimeouts","sorted","sort","_ref6","_ref7","_idA","timeoutA","_idB","timeoutB","endA","endB","call","increment","ms","toPromise","actor","Promise","resolve","reject","subscribe","complete","defaultWaitForOptions","Infinity","waitFor","predicate","resolvedOptions","res","rej","signal","aborted","reason","done","handle","dispose","sub","unsubscribe","abortListener","removeEventListener","checkEmitted","emitted","addEventListener"],"sources":["/Users/evgeniy/react-player/node_modules/xstate/dist/xstate.esm.js"],"sourcesContent":["export { createEmptyActor, fromCallback, fromEventObservable, fromObservable, fromPromise, fromTransition } from '../actors/dist/xstate-actors.esm.js';\nimport { t as toArray, S as STATE_DELIMITER, m as mapValues, f as formatTransitions, a as toTransitionConfigArray, b as formatTransition, N as NULL_EVENT, e as evaluateGuard, c as createInvokeId, g as getDelayedTransitions, d as formatInitialTransition, h as getCandidates, r as resolveStateValue, i as getAllStateNodes, j as getStateNodes, k as createMachineSnapshot, l as isInFinalState, n as macrostep, o as transitionNode, p as resolveActionsAndContext, q as createInitEvent, s as microstep, u as getInitialStateNodes, v as toStatePath, w as isStateId, x as getStateNodeByPath, y as getPersistedSnapshot, z as resolveReferencedActor, A as createActor, $ as $$ACTOR_TYPE } from './raise-0f7cf128.esm.js';\nexport { B as Actor, I as __unsafe_getAllOwnEventDescriptors, D as and, M as cancel, A as createActor, j as getStateNodes, C as interpret, H as isMachineSnapshot, J as matchesState, E as not, F as or, K as pathToStateValue, O as raise, P as spawnChild, G as stateIn, Q as stop, R as stopChild, L as toObserver } from './raise-0f7cf128.esm.js';\nimport { a as assign } from './log-15d0f775.esm.js';\nexport { S as SpecialTargets, a as assign, e as emit, b as enqueueActions, f as forwardTo, l as log, s as sendParent, c as sendTo } from './log-15d0f775.esm.js';\nimport '../dev/dist/xstate-dev.esm.js';\n\n/**\n * Asserts that the given event object is of the specified type or types. Throws\n * an error if the event object is not of the specified types.\n *\n * @example\n *\n * ```ts\n * // ...\n * entry: ({ event }) => {\n *   assertEvent(event, 'doNothing');\n *   // event is { type: 'doNothing' }\n * },\n * // ...\n * exit: ({ event }) => {\n *   assertEvent(event, 'greet');\n *   // event is { type: 'greet'; message: string }\n *\n *   assertEvent(event, ['greet', 'notify']);\n *   // event is { type: 'greet'; message: string }\n *   // or { type: 'notify'; message: string; level: 'info' | 'error' }\n * },\n * ```\n */\nfunction assertEvent(event, type) {\n  const types = toArray(type);\n  if (!types.includes(event.type)) {\n    const typesText = types.length === 1 ? `type \"${types[0]}\"` : `one of types \"${types.join('\", \"')}\"`;\n    throw new Error(`Expected event ${JSON.stringify(event)} to have ${typesText}`);\n  }\n}\n\nconst cache = new WeakMap();\nfunction memo(object, key, fn) {\n  let memoizedData = cache.get(object);\n  if (!memoizedData) {\n    memoizedData = {\n      [key]: fn()\n    };\n    cache.set(object, memoizedData);\n  } else if (!(key in memoizedData)) {\n    memoizedData[key] = fn();\n  }\n  return memoizedData[key];\n}\n\nconst EMPTY_OBJECT = {};\nconst toSerializableAction = action => {\n  if (typeof action === 'string') {\n    return {\n      type: action\n    };\n  }\n  if (typeof action === 'function') {\n    if ('resolve' in action) {\n      return {\n        type: action.type\n      };\n    }\n    return {\n      type: action.name\n    };\n  }\n  return action;\n};\nclass StateNode {\n  constructor(/** The raw config used to create the machine. */\n  config, options) {\n    this.config = config;\n    /**\n     * The relative key of the state node, which represents its location in the\n     * overall state value.\n     */\n    this.key = void 0;\n    /** The unique ID of the state node. */\n    this.id = void 0;\n    /**\n     * The type of this state node:\n     *\n     * - `'atomic'` - no child state nodes\n     * - `'compound'` - nested child state nodes (XOR)\n     * - `'parallel'` - orthogonal nested child state nodes (AND)\n     * - `'history'` - history state node\n     * - `'final'` - final state node\n     */\n    this.type = void 0;\n    /** The string path from the root machine node to this node. */\n    this.path = void 0;\n    /** The child state nodes. */\n    this.states = void 0;\n    /**\n     * The type of history on this state node. Can be:\n     *\n     * - `'shallow'` - recalls only top-level historical state value\n     * - `'deep'` - recalls historical state value at all levels\n     */\n    this.history = void 0;\n    /** The action(s) to be executed upon entering the state node. */\n    this.entry = void 0;\n    /** The action(s) to be executed upon exiting the state node. */\n    this.exit = void 0;\n    /** The parent state node. */\n    this.parent = void 0;\n    /** The root machine node. */\n    this.machine = void 0;\n    /**\n     * The meta data associated with this state node, which will be returned in\n     * State instances.\n     */\n    this.meta = void 0;\n    /**\n     * The output data sent with the \"xstate.done.state._id_\" event if this is a\n     * final state node.\n     */\n    this.output = void 0;\n    /**\n     * The order this state node appears. Corresponds to the implicit document\n     * order.\n     */\n    this.order = -1;\n    this.description = void 0;\n    this.tags = [];\n    this.transitions = void 0;\n    this.always = void 0;\n    this.parent = options._parent;\n    this.key = options._key;\n    this.machine = options._machine;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.id = this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER);\n    this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');\n    this.description = this.config.description;\n    this.order = this.machine.idMap.size;\n    this.machine.idMap.set(this.id, this);\n    this.states = this.config.states ? mapValues(this.config.states, (stateConfig, key) => {\n      const stateNode = new StateNode(stateConfig, {\n        _parent: this,\n        _key: key,\n        _machine: this.machine\n      });\n      return stateNode;\n    }) : EMPTY_OBJECT;\n    if (this.type === 'compound' && !this.config.initial) {\n      throw new Error(`No initial state specified for compound state node \"#${this.id}\". Try adding { initial: \"${Object.keys(this.states)[0]}\" } to the state config.`);\n    }\n\n    // History config\n    this.history = this.config.history === true ? 'shallow' : this.config.history || false;\n    this.entry = toArray(this.config.entry).slice();\n    this.exit = toArray(this.config.exit).slice();\n    this.meta = this.config.meta;\n    this.output = this.type === 'final' || !this.parent ? this.config.output : undefined;\n    this.tags = toArray(config.tags).slice();\n  }\n\n  /** @internal */\n  _initialize() {\n    this.transitions = formatTransitions(this);\n    if (this.config.always) {\n      this.always = toTransitionConfigArray(this.config.always).map(t => formatTransition(this, NULL_EVENT, t));\n    }\n    Object.keys(this.states).forEach(key => {\n      this.states[key]._initialize();\n    });\n  }\n\n  /** The well-structured state node definition. */\n  get definition() {\n    return {\n      id: this.id,\n      key: this.key,\n      version: this.machine.version,\n      type: this.type,\n      initial: this.initial ? {\n        target: this.initial.target,\n        source: this,\n        actions: this.initial.actions.map(toSerializableAction),\n        eventType: null,\n        reenter: false,\n        toJSON: () => ({\n          target: this.initial.target.map(t => `#${t.id}`),\n          source: `#${this.id}`,\n          actions: this.initial.actions.map(toSerializableAction),\n          eventType: null\n        })\n      } : undefined,\n      history: this.history,\n      states: mapValues(this.states, state => {\n        return state.definition;\n      }),\n      on: this.on,\n      transitions: [...this.transitions.values()].flat().map(t => ({\n        ...t,\n        actions: t.actions.map(toSerializableAction)\n      })),\n      entry: this.entry.map(toSerializableAction),\n      exit: this.exit.map(toSerializableAction),\n      meta: this.meta,\n      order: this.order || -1,\n      output: this.output,\n      invoke: this.invoke,\n      description: this.description,\n      tags: this.tags\n    };\n  }\n\n  /** @internal */\n  toJSON() {\n    return this.definition;\n  }\n\n  /** The logic invoked as actors by this state node. */\n  get invoke() {\n    return memo(this, 'invoke', () => toArray(this.config.invoke).map((invokeConfig, i) => {\n      const {\n        src,\n        systemId\n      } = invokeConfig;\n      const resolvedId = invokeConfig.id ?? createInvokeId(this.id, i);\n      const resolvedSrc = typeof src === 'string' ? src : `xstate.invoke.${createInvokeId(this.id, i)}`;\n      return {\n        ...invokeConfig,\n        src: resolvedSrc,\n        id: resolvedId,\n        systemId: systemId,\n        toJSON() {\n          const {\n            onDone,\n            onError,\n            ...invokeDefValues\n          } = invokeConfig;\n          return {\n            ...invokeDefValues,\n            type: 'xstate.invoke',\n            src: resolvedSrc,\n            id: resolvedId\n          };\n        }\n      };\n    }));\n  }\n\n  /** The mapping of events to transitions. */\n  get on() {\n    return memo(this, 'on', () => {\n      const transitions = this.transitions;\n      return [...transitions].flatMap(([descriptor, t]) => t.map(t => [descriptor, t])).reduce((map, [descriptor, transition]) => {\n        map[descriptor] = map[descriptor] || [];\n        map[descriptor].push(transition);\n        return map;\n      }, {});\n    });\n  }\n  get after() {\n    return memo(this, 'delayedTransitions', () => getDelayedTransitions(this));\n  }\n  get initial() {\n    return memo(this, 'initial', () => formatInitialTransition(this, this.config.initial));\n  }\n\n  /** @internal */\n  next(snapshot, event) {\n    const eventType = event.type;\n    const actions = [];\n    let selectedTransition;\n    const candidates = memo(this, `candidates-${eventType}`, () => getCandidates(this, eventType));\n    for (const candidate of candidates) {\n      const {\n        guard\n      } = candidate;\n      const resolvedContext = snapshot.context;\n      let guardPassed = false;\n      try {\n        guardPassed = !guard || evaluateGuard(guard, resolvedContext, event, snapshot);\n      } catch (err) {\n        const guardType = typeof guard === 'string' ? guard : typeof guard === 'object' ? guard.type : undefined;\n        throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ''}in transition for event '${eventType}' in state node '${this.id}':\\n${err.message}`);\n      }\n      if (guardPassed) {\n        actions.push(...candidate.actions);\n        selectedTransition = candidate;\n        break;\n      }\n    }\n    return selectedTransition ? [selectedTransition] : undefined;\n  }\n\n  /** All the event types accepted by this state node and its descendants. */\n  get events() {\n    return memo(this, 'events', () => {\n      const {\n        states\n      } = this;\n      const events = new Set(this.ownEvents);\n      if (states) {\n        for (const stateId of Object.keys(states)) {\n          const state = states[stateId];\n          if (state.states) {\n            for (const event of state.events) {\n              events.add(`${event}`);\n            }\n          }\n        }\n      }\n      return Array.from(events);\n    });\n  }\n\n  /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */\n  get ownEvents() {\n    const events = new Set([...this.transitions.keys()].filter(descriptor => {\n      return this.transitions.get(descriptor).some(transition => !(!transition.target && !transition.actions.length && !transition.reenter));\n    }));\n    return Array.from(events);\n  }\n}\n\nconst STATE_IDENTIFIER = '#';\nclass StateMachine {\n  constructor(/** The raw config used to create the machine. */\n  config, implementations) {\n    this.config = config;\n    /** The machine's own version. */\n    this.version = void 0;\n    this.schemas = void 0;\n    this.implementations = void 0;\n    /** @internal */\n    this.__xstatenode = true;\n    /** @internal */\n    this.idMap = new Map();\n    this.root = void 0;\n    this.id = void 0;\n    this.states = void 0;\n    this.events = void 0;\n    this.id = config.id || '(machine)';\n    this.implementations = {\n      actors: implementations?.actors ?? {},\n      actions: implementations?.actions ?? {},\n      delays: implementations?.delays ?? {},\n      guards: implementations?.guards ?? {}\n    };\n    this.version = this.config.version;\n    this.schemas = this.config.schemas;\n    this.transition = this.transition.bind(this);\n    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n    this.restoreSnapshot = this.restoreSnapshot.bind(this);\n    this.start = this.start.bind(this);\n    this.root = new StateNode(config, {\n      _key: this.id,\n      _machine: this\n    });\n    this.root._initialize();\n    this.states = this.root.states; // TODO: remove!\n    this.events = this.root.events;\n  }\n\n  /**\n   * Clones this state machine with the provided implementations and merges the\n   * `context` (if provided).\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`,\n   *   `context`) to recursively merge with the existing options.\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */\n  provide(implementations) {\n    const {\n      actions,\n      guards,\n      actors,\n      delays\n    } = this.implementations;\n    return new StateMachine(this.config, {\n      actions: {\n        ...actions,\n        ...implementations.actions\n      },\n      guards: {\n        ...guards,\n        ...implementations.guards\n      },\n      actors: {\n        ...actors,\n        ...implementations.actors\n      },\n      delays: {\n        ...delays,\n        ...implementations.delays\n      }\n    });\n  }\n  resolveState(config) {\n    const resolvedStateValue = resolveStateValue(this.root, config.value);\n    const nodeSet = getAllStateNodes(getStateNodes(this.root, resolvedStateValue));\n    return createMachineSnapshot({\n      _nodes: [...nodeSet],\n      context: config.context || {},\n      children: {},\n      status: isInFinalState(nodeSet, this.root) ? 'done' : config.status || 'active',\n      output: config.output,\n      error: config.error,\n      historyValue: config.historyValue\n    }, this);\n  }\n\n  /**\n   * Determines the next snapshot given the current `snapshot` and received\n   * `event`. Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */\n  transition(snapshot, event, actorScope) {\n    return macrostep(snapshot, event, actorScope).snapshot;\n  }\n\n  /**\n   * Determines the next state given the current `state` and `event`. Calculates\n   * a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */\n  microstep(snapshot, event, actorScope) {\n    return macrostep(snapshot, event, actorScope).microstates;\n  }\n  getTransitionData(snapshot, event) {\n    return transitionNode(this.root, snapshot.value, snapshot, event) || [];\n  }\n\n  /**\n   * The initial state _before_ evaluating any microsteps. This \"pre-initial\"\n   * state is provided to initial actions executed in the initial state.\n   */\n  getPreInitialState(actorScope, initEvent, internalQueue) {\n    const {\n      context\n    } = this.config;\n    const preInitial = createMachineSnapshot({\n      context: typeof context !== 'function' && context ? context : {},\n      _nodes: [this.root],\n      children: {},\n      status: 'active'\n    }, this);\n    if (typeof context === 'function') {\n      const assignment = ({\n        spawn,\n        event,\n        self\n      }) => context({\n        spawn,\n        input: event.input,\n        self\n      });\n      return resolveActionsAndContext(preInitial, initEvent, actorScope, [assign(assignment)], internalQueue);\n    }\n    return preInitial;\n  }\n\n  /**\n   * Returns the initial `State` instance, with reference to `self` as an\n   * `ActorRef`.\n   */\n  getInitialSnapshot(actorScope, input) {\n    const initEvent = createInitEvent(input); // TODO: fix;\n    const internalQueue = [];\n    const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);\n    const nextState = microstep([{\n      target: [...getInitialStateNodes(this.root)],\n      source: this.root,\n      reenter: true,\n      actions: [],\n      eventType: null,\n      toJSON: null // TODO: fix\n    }], preInitialState, actorScope, initEvent, true, internalQueue);\n    const {\n      snapshot: macroState\n    } = macrostep(nextState, initEvent, actorScope, internalQueue);\n    return macroState;\n  }\n  start(snapshot) {\n    Object.values(snapshot.children).forEach(child => {\n      if (child.getSnapshot().status === 'active') {\n        child.start();\n      }\n    });\n  }\n  getStateNodeById(stateId) {\n    const fullPath = toStatePath(stateId);\n    const relativePath = fullPath.slice(1);\n    const resolvedStateId = isStateId(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];\n    const stateNode = this.idMap.get(resolvedStateId);\n    if (!stateNode) {\n      throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);\n    }\n    return getStateNodeByPath(stateNode, relativePath);\n  }\n  get definition() {\n    return this.root.definition;\n  }\n  toJSON() {\n    return this.definition;\n  }\n  getPersistedSnapshot(snapshot, options) {\n    return getPersistedSnapshot(snapshot, options);\n  }\n  restoreSnapshot(snapshot, _actorScope) {\n    const children = {};\n    const snapshotChildren = snapshot.children;\n    Object.keys(snapshotChildren).forEach(actorId => {\n      const actorData = snapshotChildren[actorId];\n      const childState = actorData.snapshot;\n      const src = actorData.src;\n      const logic = typeof src === 'string' ? resolveReferencedActor(this, src) : src;\n      if (!logic) {\n        return;\n      }\n      const actorRef = createActor(logic, {\n        id: actorId,\n        parent: _actorScope.self,\n        syncSnapshot: actorData.syncSnapshot,\n        snapshot: childState,\n        src,\n        systemId: actorData.systemId\n      });\n      children[actorId] = actorRef;\n    });\n    const restoredSnapshot = createMachineSnapshot({\n      ...snapshot,\n      children,\n      _nodes: Array.from(getAllStateNodes(getStateNodes(this.root, snapshot.value)))\n    }, this);\n    let seen = new Set();\n    function reviveContext(contextPart, children) {\n      if (seen.has(contextPart)) {\n        return;\n      }\n      seen.add(contextPart);\n      for (let key in contextPart) {\n        const value = contextPart[key];\n        if (value && typeof value === 'object') {\n          if ('xstate$$type' in value && value.xstate$$type === $$ACTOR_TYPE) {\n            contextPart[key] = children[value.id];\n            continue;\n          }\n          reviveContext(value, children);\n        }\n      }\n    }\n    reviveContext(restoredSnapshot.context, children);\n    return restoredSnapshot;\n  }\n}\n\n// this is not 100% accurate since we can't make parallel regions required in the result\n// `TTestValue` doesn't encode this information anyhow for us to be able to do that\n// this is fine for most practical use cases anyway though\n\n/**\n * Creates a state machine (statechart) with the given configuration.\n *\n * The state machine represents the pure logic of a state machine actor.\n *\n * @example\n *\n * ```ts\n * import { createMachine } from 'xstate';\n *\n * const lightMachine = createMachine({\n *   id: 'light',\n *   initial: 'green',\n *   states: {\n *     green: {\n *       on: {\n *         TIMER: { target: 'yellow' }\n *       }\n *     },\n *     yellow: {\n *       on: {\n *         TIMER: { target: 'red' }\n *       }\n *     },\n *     red: {\n *       on: {\n *         TIMER: { target: 'green' }\n *       }\n *     }\n *   }\n * });\n *\n * const lightActor = createActor(lightMachine);\n * lightActor.start();\n *\n * lightActor.send({ type: 'TIMER' });\n * ```\n *\n * @param config The state machine configuration.\n * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })`\n *   to provide machine implementations instead.\n */\nfunction createMachine(config, implementations) {\n  return new StateMachine(config, implementations);\n}\n\n/** @internal */\nfunction createInertActorScope(actorLogic) {\n  const self = createActor(actorLogic);\n  const inertActorScope = {\n    self,\n    defer: () => {},\n    id: '',\n    logger: () => {},\n    sessionId: '',\n    stopChild: () => {},\n    system: self.system,\n    emit: () => {}\n  };\n  return inertActorScope;\n}\nfunction getInitialSnapshot(actorLogic, ...[input]) {\n  const actorScope = createInertActorScope(actorLogic);\n  return actorLogic.getInitialSnapshot(actorScope, input);\n}\n\n/**\n * Determines the next snapshot for the given `actorLogic` based on the given\n * `snapshot` and `event`.\n *\n * If the `snapshot` is `undefined`, the initial snapshot of the `actorLogic` is\n * used.\n *\n * @example\n *\n * ```ts\n * import { getNextSnapshot } from 'xstate';\n * import { trafficLightMachine } from './trafficLightMachine.ts';\n *\n * const nextSnapshot = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   undefined, // snapshot (or initial state if undefined)\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot.value);\n * // => 'yellow'\n *\n * const nextSnapshot2 = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   nextSnapshot, // snapshot\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot2.value);\n * // =>'red'\n * ```\n */\nfunction getNextSnapshot(actorLogic, snapshot, event) {\n  const inertActorScope = createInertActorScope(actorLogic);\n  inertActorScope.self._snapshot = snapshot;\n  return actorLogic.transition(snapshot, event, inertActorScope);\n}\n\n// at the moment we allow extra actors - ones that are not specified by `children`\n// this could be reconsidered in the future\n\nfunction setup({\n  schemas,\n  actors,\n  actions,\n  guards,\n  delays\n}) {\n  return {\n    createMachine: config => createMachine({\n      ...config,\n      schemas\n    }, {\n      actors,\n      actions,\n      guards,\n      delays\n    })\n  };\n}\n\nclass SimulatedClock {\n  constructor() {\n    this.timeouts = new Map();\n    this._now = 0;\n    this._id = 0;\n    this._flushing = false;\n    this._flushingInvalidated = false;\n  }\n  now() {\n    return this._now;\n  }\n  getId() {\n    return this._id++;\n  }\n  setTimeout(fn, timeout) {\n    this._flushingInvalidated = this._flushing;\n    const id = this.getId();\n    this.timeouts.set(id, {\n      start: this.now(),\n      timeout,\n      fn\n    });\n    return id;\n  }\n  clearTimeout(id) {\n    this._flushingInvalidated = this._flushing;\n    this.timeouts.delete(id);\n  }\n  set(time) {\n    if (this._now > time) {\n      throw new Error('Unable to travel back in time');\n    }\n    this._now = time;\n    this.flushTimeouts();\n  }\n  flushTimeouts() {\n    if (this._flushing) {\n      this._flushingInvalidated = true;\n      return;\n    }\n    this._flushing = true;\n    const sorted = [...this.timeouts].sort(([_idA, timeoutA], [_idB, timeoutB]) => {\n      const endA = timeoutA.start + timeoutA.timeout;\n      const endB = timeoutB.start + timeoutB.timeout;\n      return endB > endA ? -1 : 1;\n    });\n    for (const [id, timeout] of sorted) {\n      if (this._flushingInvalidated) {\n        this._flushingInvalidated = false;\n        this._flushing = false;\n        this.flushTimeouts();\n        return;\n      }\n      if (this.now() - timeout.start >= timeout.timeout) {\n        this.timeouts.delete(id);\n        timeout.fn.call(null);\n      }\n    }\n    this._flushing = false;\n  }\n  increment(ms) {\n    this._now += ms;\n    this.flushTimeouts();\n  }\n}\n\n/**\n * Returns a promise that resolves to the `output` of the actor when it is done.\n *\n * @example\n *\n * ```ts\n * const machine = createMachine({\n *   // ...\n *   output: {\n *     count: 42\n *   }\n * });\n *\n * const actor = createActor(machine);\n *\n * actor.start();\n *\n * const output = await toPromise(actor);\n *\n * console.log(output);\n * // logs { count: 42 }\n * ```\n */\nfunction toPromise(actor) {\n  return new Promise((resolve, reject) => {\n    actor.subscribe({\n      complete: () => {\n        resolve(actor.getSnapshot().output);\n      },\n      error: reject\n    });\n  });\n}\n\nconst defaultWaitForOptions = {\n  timeout: Infinity // much more than 10 seconds\n};\n\n/**\n * Subscribes to an actor ref and waits for its emitted value to satisfy a\n * predicate, and then resolves with that value. Will throw if the desired state\n * is not reached after an optional timeout. (defaults to Infinity).\n *\n * @example\n *\n * ```js\n * const state = await waitFor(someService, (state) => {\n *   return state.hasTag('loaded');\n * });\n *\n * state.hasTag('loaded'); // true\n * ```\n *\n * @param actorRef The actor ref to subscribe to\n * @param predicate Determines if a value matches the condition to wait for\n * @param options\n * @returns A promise that eventually resolves to the emitted value that matches\n *   the condition\n */\nfunction waitFor(actorRef, predicate, options) {\n  const resolvedOptions = {\n    ...defaultWaitForOptions,\n    ...options\n  };\n  return new Promise((res, rej) => {\n    const {\n      signal\n    } = resolvedOptions;\n    if (signal?.aborted) {\n      rej(signal.reason);\n      return;\n    }\n    let done = false;\n    const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(() => {\n      dispose();\n      rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));\n    }, resolvedOptions.timeout);\n    const dispose = () => {\n      clearTimeout(handle);\n      done = true;\n      sub?.unsubscribe();\n      if (abortListener) {\n        signal.removeEventListener('abort', abortListener);\n      }\n    };\n    function checkEmitted(emitted) {\n      if (predicate(emitted)) {\n        dispose();\n        res(emitted);\n      }\n    }\n\n    /**\n     * If the `signal` option is provided, this will be the listener for its\n     * `abort` event\n     */\n    let abortListener;\n    let sub; // avoid TDZ when disposing synchronously\n\n    // See if the current snapshot already matches the predicate\n    checkEmitted(actorRef.getSnapshot());\n    if (done) {\n      return;\n    }\n\n    // only define the `abortListener` if the `signal` option is provided\n    if (signal) {\n      abortListener = () => {\n        dispose();\n        // XState does not \"own\" the signal, so we should reject with its reason (if any)\n        rej(signal.reason);\n      };\n      signal.addEventListener('abort', abortListener);\n    }\n    sub = actorRef.subscribe({\n      next: checkEmitted,\n      error: err => {\n        dispose();\n        rej(err);\n      },\n      complete: () => {\n        dispose();\n        rej(new Error(`Actor terminated without satisfying predicate`));\n      }\n    });\n    if (done) {\n      sub.unsubscribe();\n    }\n  });\n}\n\nexport { SimulatedClock, StateMachine, StateNode, assertEvent, createMachine, getInitialSnapshot, getNextSnapshot, setup, toPromise, waitFor };\n"],"mappings":"AAAA,SAASA,gBAAgB,EAAEC,YAAY,EAAEC,mBAAmB,EAAEC,cAAc,EAAEC,WAAW,EAAEC,cAAc,QAAQ,qCAAqC;AACtJ,SAASC,CAAC,IAAIC,OAAO,EAAEC,CAAC,IAAIC,eAAe,EAAEC,CAAC,IAAIC,SAAS,EAAEC,CAAC,IAAIC,iBAAiB,EAAEC,CAAC,IAAIC,uBAAuB,EAAEC,CAAC,IAAIC,gBAAgB,EAAEC,CAAC,IAAIC,UAAU,EAAEC,CAAC,IAAIC,aAAa,EAAEC,CAAC,IAAIC,cAAc,EAAEC,CAAC,IAAIC,qBAAqB,EAAEC,CAAC,IAAIC,uBAAuB,EAAEC,CAAC,IAAIC,aAAa,EAAEC,CAAC,IAAIC,iBAAiB,EAAEC,CAAC,IAAIC,gBAAgB,EAAEC,CAAC,IAAIC,aAAa,EAAEC,CAAC,IAAIC,qBAAqB,EAAEC,CAAC,IAAIC,cAAc,EAAEC,CAAC,IAAIC,SAAS,EAAEC,CAAC,IAAIC,cAAc,EAAEC,CAAC,IAAIC,wBAAwB,EAAEC,CAAC,IAAIC,eAAe,EAAEC,CAAC,IAAIC,SAAS,EAAEC,CAAC,IAAIC,oBAAoB,EAAEC,CAAC,IAAIC,WAAW,EAAEC,CAAC,IAAIC,SAAS,EAAEC,CAAC,IAAIC,kBAAkB,EAAEC,CAAC,IAAIC,oBAAoB,EAAEC,CAAC,IAAIC,sBAAsB,EAAEC,CAAC,IAAIC,WAAW,EAAEC,CAAC,IAAIC,YAAY,QAAQ,yBAAyB;AAClsB,SAASC,CAAC,IAAIC,KAAK,EAAEC,CAAC,IAAIC,kCAAkC,EAAEC,CAAC,IAAIC,GAAG,EAAEC,CAAC,IAAIC,MAAM,EAAEX,CAAC,IAAIC,WAAW,EAAE7B,CAAC,IAAIC,aAAa,EAAEuC,CAAC,IAAIC,SAAS,EAAEC,CAAC,IAAIC,iBAAiB,EAAEC,CAAC,IAAIC,YAAY,EAAEC,CAAC,IAAIC,GAAG,EAAEC,CAAC,IAAIC,EAAE,EAAEC,CAAC,IAAIC,gBAAgB,EAAEC,CAAC,IAAIC,KAAK,EAAEC,CAAC,IAAIC,UAAU,EAAEC,CAAC,IAAIC,OAAO,EAAEC,CAAC,IAAIC,IAAI,EAAEC,CAAC,IAAIC,SAAS,EAAEC,CAAC,IAAIC,UAAU,QAAQ,yBAAyB;AACtV,SAASnF,CAAC,IAAIoF,MAAM,QAAQ,uBAAuB;AACnD,SAAS1F,CAAC,IAAI2F,cAAc,EAAErF,CAAC,IAAIoF,MAAM,EAAE9E,CAAC,IAAIgF,IAAI,EAAEpF,CAAC,IAAIqF,cAAc,EAAEzF,CAAC,IAAI0F,SAAS,EAAEhE,CAAC,IAAIiE,GAAG,EAAEvD,CAAC,IAAIwD,UAAU,EAAElF,CAAC,IAAImF,MAAM,QAAQ,uBAAuB;AAChK,OAAO,+BAA+B;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,WAAWA,CAACC,KAAK,EAAEC,IAAI,EAAE;EAChC,MAAMC,KAAK,GAAGtG,OAAO,CAACqG,IAAI,CAAC;EAC3B,IAAI,CAACC,KAAK,CAACC,QAAQ,CAACH,KAAK,CAACC,IAAI,CAAC,EAAE;IAC/B,MAAMG,SAAS,GAAGF,KAAK,CAACG,MAAM,KAAK,CAAC,GAAG,SAASH,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,iBAAiBA,KAAK,CAACI,IAAI,CAAC,MAAM,CAAC,GAAG;IACpG,MAAM,IAAIC,KAAK,CAAC,kBAAkBC,IAAI,CAACC,SAAS,CAACT,KAAK,CAAC,YAAYI,SAAS,EAAE,CAAC;EACjF;AACF;AAEA,MAAMM,KAAK,GAAG,IAAIC,OAAO,CAAC,CAAC;AAC3B,SAASC,IAAIA,CAACC,MAAM,EAAEC,GAAG,EAAEC,EAAE,EAAE;EAC7B,IAAIC,YAAY,GAAGN,KAAK,CAACO,GAAG,CAACJ,MAAM,CAAC;EACpC,IAAI,CAACG,YAAY,EAAE;IACjBA,YAAY,GAAG;MACb,CAACF,GAAG,GAAGC,EAAE,CAAC;IACZ,CAAC;IACDL,KAAK,CAACQ,GAAG,CAACL,MAAM,EAAEG,YAAY,CAAC;EACjC,CAAC,MAAM,IAAI,EAAEF,GAAG,IAAIE,YAAY,CAAC,EAAE;IACjCA,YAAY,CAACF,GAAG,CAAC,GAAGC,EAAE,CAAC,CAAC;EAC1B;EACA,OAAOC,YAAY,CAACF,GAAG,CAAC;AAC1B;AAEA,MAAMK,YAAY,GAAG,CAAC,CAAC;AACvB,MAAMC,oBAAoB,GAAGC,MAAM,IAAI;EACrC,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IAC9B,OAAO;MACLpB,IAAI,EAAEoB;IACR,CAAC;EACH;EACA,IAAI,OAAOA,MAAM,KAAK,UAAU,EAAE;IAChC,IAAI,SAAS,IAAIA,MAAM,EAAE;MACvB,OAAO;QACLpB,IAAI,EAAEoB,MAAM,CAACpB;MACf,CAAC;IACH;IACA,OAAO;MACLA,IAAI,EAAEoB,MAAM,CAACC;IACf,CAAC;EACH;EACA,OAAOD,MAAM;AACf,CAAC;AACD,MAAME,SAAS,CAAC;EACdC,WAAWA,CAAC;EACZC,MAAM,EAAEC,OAAO,EAAE;IACf,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB;AACJ;AACA;AACA;IACI,IAAI,CAACX,GAAG,GAAG,KAAK,CAAC;IACjB;IACA,IAAI,CAACa,EAAE,GAAG,KAAK,CAAC;IAChB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAAC1B,IAAI,GAAG,KAAK,CAAC;IAClB;IACA,IAAI,CAAC2B,IAAI,GAAG,KAAK,CAAC;IAClB;IACA,IAAI,CAACC,MAAM,GAAG,KAAK,CAAC;IACpB;AACJ;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,OAAO,GAAG,KAAK,CAAC;IACrB;IACA,IAAI,CAACC,KAAK,GAAG,KAAK,CAAC;IACnB;IACA,IAAI,CAACC,IAAI,GAAG,KAAK,CAAC;IAClB;IACA,IAAI,CAACC,MAAM,GAAG,KAAK,CAAC;IACpB;IACA,IAAI,CAACC,OAAO,GAAG,KAAK,CAAC;IACrB;AACJ;AACA;AACA;IACI,IAAI,CAACC,IAAI,GAAG,KAAK,CAAC;IAClB;AACJ;AACA;AACA;IACI,IAAI,CAACC,MAAM,GAAG,KAAK,CAAC;IACpB;AACJ;AACA;AACA;IACI,IAAI,CAACC,KAAK,GAAG,CAAC,CAAC;IACf,IAAI,CAACC,WAAW,GAAG,KAAK,CAAC;IACzB,IAAI,CAACC,IAAI,GAAG,EAAE;IACd,IAAI,CAACC,WAAW,GAAG,KAAK,CAAC;IACzB,IAAI,CAACC,MAAM,GAAG,KAAK,CAAC;IACpB,IAAI,CAACR,MAAM,GAAGP,OAAO,CAACgB,OAAO;IAC7B,IAAI,CAAC5B,GAAG,GAAGY,OAAO,CAACiB,IAAI;IACvB,IAAI,CAACT,OAAO,GAAGR,OAAO,CAACkB,QAAQ;IAC/B,IAAI,CAAChB,IAAI,GAAG,IAAI,CAACK,MAAM,GAAG,IAAI,CAACA,MAAM,CAACL,IAAI,CAACiB,MAAM,CAAC,IAAI,CAAC/B,GAAG,CAAC,GAAG,EAAE;IAChE,IAAI,CAACa,EAAE,GAAG,IAAI,CAACF,MAAM,CAACE,EAAE,IAAI,CAAC,IAAI,CAACO,OAAO,CAACP,EAAE,EAAE,GAAG,IAAI,CAACC,IAAI,CAAC,CAACtB,IAAI,CAACxG,eAAe,CAAC;IACjF,IAAI,CAACmG,IAAI,GAAG,IAAI,CAACwB,MAAM,CAACxB,IAAI,KAAK,IAAI,CAACwB,MAAM,CAACI,MAAM,IAAIiB,MAAM,CAACC,IAAI,CAAC,IAAI,CAACtB,MAAM,CAACI,MAAM,CAAC,CAACxB,MAAM,GAAG,UAAU,GAAG,IAAI,CAACoB,MAAM,CAACK,OAAO,GAAG,SAAS,GAAG,QAAQ,CAAC;IACxJ,IAAI,CAACQ,WAAW,GAAG,IAAI,CAACb,MAAM,CAACa,WAAW;IAC1C,IAAI,CAACD,KAAK,GAAG,IAAI,CAACH,OAAO,CAACc,KAAK,CAACC,IAAI;IACpC,IAAI,CAACf,OAAO,CAACc,KAAK,CAAC9B,GAAG,CAAC,IAAI,CAACS,EAAE,EAAE,IAAI,CAAC;IACrC,IAAI,CAACE,MAAM,GAAG,IAAI,CAACJ,MAAM,CAACI,MAAM,GAAG7H,SAAS,CAAC,IAAI,CAACyH,MAAM,CAACI,MAAM,EAAE,CAACqB,WAAW,EAAEpC,GAAG,KAAK;MACrF,MAAMqC,SAAS,GAAG,IAAI5B,SAAS,CAAC2B,WAAW,EAAE;QAC3CR,OAAO,EAAE,IAAI;QACbC,IAAI,EAAE7B,GAAG;QACT8B,QAAQ,EAAE,IAAI,CAACV;MACjB,CAAC,CAAC;MACF,OAAOiB,SAAS;IAClB,CAAC,CAAC,GAAGhC,YAAY;IACjB,IAAI,IAAI,CAAClB,IAAI,KAAK,UAAU,IAAI,CAAC,IAAI,CAACwB,MAAM,CAAC2B,OAAO,EAAE;MACpD,MAAM,IAAI7C,KAAK,CAAC,wDAAwD,IAAI,CAACoB,EAAE,6BAA6BmB,MAAM,CAACC,IAAI,CAAC,IAAI,CAAClB,MAAM,CAAC,CAAC,CAAC,CAAC,0BAA0B,CAAC;IACpK;;IAEA;IACA,IAAI,CAACC,OAAO,GAAG,IAAI,CAACL,MAAM,CAACK,OAAO,KAAK,IAAI,GAAG,SAAS,GAAG,IAAI,CAACL,MAAM,CAACK,OAAO,IAAI,KAAK;IACtF,IAAI,CAACC,KAAK,GAAGnI,OAAO,CAAC,IAAI,CAAC6H,MAAM,CAACM,KAAK,CAAC,CAACsB,KAAK,CAAC,CAAC;IAC/C,IAAI,CAACrB,IAAI,GAAGpI,OAAO,CAAC,IAAI,CAAC6H,MAAM,CAACO,IAAI,CAAC,CAACqB,KAAK,CAAC,CAAC;IAC7C,IAAI,CAAClB,IAAI,GAAG,IAAI,CAACV,MAAM,CAACU,IAAI;IAC5B,IAAI,CAACC,MAAM,GAAG,IAAI,CAACnC,IAAI,KAAK,OAAO,IAAI,CAAC,IAAI,CAACgC,MAAM,GAAG,IAAI,CAACR,MAAM,CAACW,MAAM,GAAGkB,SAAS;IACpF,IAAI,CAACf,IAAI,GAAG3I,OAAO,CAAC6H,MAAM,CAACc,IAAI,CAAC,CAACc,KAAK,CAAC,CAAC;EAC1C;;EAEA;EACAE,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACf,WAAW,GAAGtI,iBAAiB,CAAC,IAAI,CAAC;IAC1C,IAAI,IAAI,CAACuH,MAAM,CAACgB,MAAM,EAAE;MACtB,IAAI,CAACA,MAAM,GAAGrI,uBAAuB,CAAC,IAAI,CAACqH,MAAM,CAACgB,MAAM,CAAC,CAACe,GAAG,CAAC7J,CAAC,IAAIW,gBAAgB,CAAC,IAAI,EAAEE,UAAU,EAAEb,CAAC,CAAC,CAAC;IAC3G;IACAmJ,MAAM,CAACC,IAAI,CAAC,IAAI,CAAClB,MAAM,CAAC,CAAC4B,OAAO,CAAC3C,GAAG,IAAI;MACtC,IAAI,CAACe,MAAM,CAACf,GAAG,CAAC,CAACyC,WAAW,CAAC,CAAC;IAChC,CAAC,CAAC;EACJ;;EAEA;EACA,IAAIG,UAAUA,CAAA,EAAG;IACf,OAAO;MACL/B,EAAE,EAAE,IAAI,CAACA,EAAE;MACXb,GAAG,EAAE,IAAI,CAACA,GAAG;MACb6C,OAAO,EAAE,IAAI,CAACzB,OAAO,CAACyB,OAAO;MAC7B1D,IAAI,EAAE,IAAI,CAACA,IAAI;MACfmD,OAAO,EAAE,IAAI,CAACA,OAAO,GAAG;QACtBQ,MAAM,EAAE,IAAI,CAACR,OAAO,CAACQ,MAAM;QAC3BC,MAAM,EAAE,IAAI;QACZC,OAAO,EAAE,IAAI,CAACV,OAAO,CAACU,OAAO,CAACN,GAAG,CAACpC,oBAAoB,CAAC;QACvD2C,SAAS,EAAE,IAAI;QACfC,OAAO,EAAE,KAAK;QACdC,MAAM,EAAEA,CAAA,MAAO;UACbL,MAAM,EAAE,IAAI,CAACR,OAAO,CAACQ,MAAM,CAACJ,GAAG,CAAC7J,CAAC,IAAI,IAAIA,CAAC,CAACgI,EAAE,EAAE,CAAC;UAChDkC,MAAM,EAAE,IAAI,IAAI,CAAClC,EAAE,EAAE;UACrBmC,OAAO,EAAE,IAAI,CAACV,OAAO,CAACU,OAAO,CAACN,GAAG,CAACpC,oBAAoB,CAAC;UACvD2C,SAAS,EAAE;QACb,CAAC;MACH,CAAC,GAAGT,SAAS;MACbxB,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBD,MAAM,EAAE7H,SAAS,CAAC,IAAI,CAAC6H,MAAM,EAAEqC,KAAK,IAAI;QACtC,OAAOA,KAAK,CAACR,UAAU;MACzB,CAAC,CAAC;MACFS,EAAE,EAAE,IAAI,CAACA,EAAE;MACX3B,WAAW,EAAE,CAAC,GAAG,IAAI,CAACA,WAAW,CAAC4B,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAACb,GAAG,CAAC7J,CAAC,KAAK;QAC3D,GAAGA,CAAC;QACJmK,OAAO,EAAEnK,CAAC,CAACmK,OAAO,CAACN,GAAG,CAACpC,oBAAoB;MAC7C,CAAC,CAAC,CAAC;MACHW,KAAK,EAAE,IAAI,CAACA,KAAK,CAACyB,GAAG,CAACpC,oBAAoB,CAAC;MAC3CY,IAAI,EAAE,IAAI,CAACA,IAAI,CAACwB,GAAG,CAACpC,oBAAoB,CAAC;MACzCe,IAAI,EAAE,IAAI,CAACA,IAAI;MACfE,KAAK,EAAE,IAAI,CAACA,KAAK,IAAI,CAAC,CAAC;MACvBD,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBkC,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBhC,WAAW,EAAE,IAAI,CAACA,WAAW;MAC7BC,IAAI,EAAE,IAAI,CAACA;IACb,CAAC;EACH;;EAEA;EACA0B,MAAMA,CAAA,EAAG;IACP,OAAO,IAAI,CAACP,UAAU;EACxB;;EAEA;EACA,IAAIY,MAAMA,CAAA,EAAG;IACX,OAAO1D,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,MAAMhH,OAAO,CAAC,IAAI,CAAC6H,MAAM,CAAC6C,MAAM,CAAC,CAACd,GAAG,CAAC,CAACe,YAAY,EAAElJ,CAAC,KAAK;MACrF,MAAM;QACJmJ,GAAG;QACHC;MACF,CAAC,GAAGF,YAAY;MAChB,MAAMG,UAAU,GAAGH,YAAY,CAAC5C,EAAE,IAAI/G,cAAc,CAAC,IAAI,CAAC+G,EAAE,EAAEtG,CAAC,CAAC;MAChE,MAAMsJ,WAAW,GAAG,OAAOH,GAAG,KAAK,QAAQ,GAAGA,GAAG,GAAG,iBAAiB5J,cAAc,CAAC,IAAI,CAAC+G,EAAE,EAAEtG,CAAC,CAAC,EAAE;MACjG,OAAO;QACL,GAAGkJ,YAAY;QACfC,GAAG,EAAEG,WAAW;QAChBhD,EAAE,EAAE+C,UAAU;QACdD,QAAQ,EAAEA,QAAQ;QAClBR,MAAMA,CAAA,EAAG;UACP,MAAM;YACJW,MAAM;YACNC,OAAO;YACP,GAAGC;UACL,CAAC,GAAGP,YAAY;UAChB,OAAO;YACL,GAAGO,eAAe;YAClB7E,IAAI,EAAE,eAAe;YACrBuE,GAAG,EAAEG,WAAW;YAChBhD,EAAE,EAAE+C;UACN,CAAC;QACH;MACF,CAAC;IACH,CAAC,CAAC,CAAC;EACL;;EAEA;EACA,IAAIP,EAAEA,CAAA,EAAG;IACP,OAAOvD,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,MAAM;MAC5B,MAAM4B,WAAW,GAAG,IAAI,CAACA,WAAW;MACpC,OAAO,CAAC,GAAGA,WAAW,CAAC,CAACuC,OAAO,CAACC,IAAA;QAAA,IAAC,CAACC,UAAU,EAAEtL,CAAC,CAAC,GAAAqL,IAAA;QAAA,OAAKrL,CAAC,CAAC6J,GAAG,CAAC7J,CAAC,IAAI,CAACsL,UAAU,EAAEtL,CAAC,CAAC,CAAC;MAAA,EAAC,CAACuL,MAAM,CAAC,CAAC1B,GAAG,EAAA2B,KAAA,KAA+B;QAAA,IAA7B,CAACF,UAAU,EAAEG,UAAU,CAAC,GAAAD,KAAA;QACrH3B,GAAG,CAACyB,UAAU,CAAC,GAAGzB,GAAG,CAACyB,UAAU,CAAC,IAAI,EAAE;QACvCzB,GAAG,CAACyB,UAAU,CAAC,CAACI,IAAI,CAACD,UAAU,CAAC;QAChC,OAAO5B,GAAG;MACZ,CAAC,EAAE,CAAC,CAAC,CAAC;IACR,CAAC,CAAC;EACJ;EACA,IAAI8B,KAAKA,CAAA,EAAG;IACV,OAAO1E,IAAI,CAAC,IAAI,EAAE,oBAAoB,EAAE,MAAM9F,qBAAqB,CAAC,IAAI,CAAC,CAAC;EAC5E;EACA,IAAIsI,OAAOA,CAAA,EAAG;IACZ,OAAOxC,IAAI,CAAC,IAAI,EAAE,SAAS,EAAE,MAAM5F,uBAAuB,CAAC,IAAI,EAAE,IAAI,CAACyG,MAAM,CAAC2B,OAAO,CAAC,CAAC;EACxF;;EAEA;EACAmC,IAAIA,CAACC,QAAQ,EAAExF,KAAK,EAAE;IACpB,MAAM+D,SAAS,GAAG/D,KAAK,CAACC,IAAI;IAC5B,MAAM6D,OAAO,GAAG,EAAE;IAClB,IAAI2B,kBAAkB;IACtB,MAAMC,UAAU,GAAG9E,IAAI,CAAC,IAAI,EAAE,cAAcmD,SAAS,EAAE,EAAE,MAAM7I,aAAa,CAAC,IAAI,EAAE6I,SAAS,CAAC,CAAC;IAC9F,KAAK,MAAM4B,SAAS,IAAID,UAAU,EAAE;MAClC,MAAM;QACJE;MACF,CAAC,GAAGD,SAAS;MACb,MAAME,eAAe,GAAGL,QAAQ,CAACM,OAAO;MACxC,IAAIC,WAAW,GAAG,KAAK;MACvB,IAAI;QACFA,WAAW,GAAG,CAACH,KAAK,IAAIlL,aAAa,CAACkL,KAAK,EAAEC,eAAe,EAAE7F,KAAK,EAAEwF,QAAQ,CAAC;MAChF,CAAC,CAAC,OAAOQ,GAAG,EAAE;QACZ,MAAMC,SAAS,GAAG,OAAOL,KAAK,KAAK,QAAQ,GAAGA,KAAK,GAAG,OAAOA,KAAK,KAAK,QAAQ,GAAGA,KAAK,CAAC3F,IAAI,GAAGqD,SAAS;QACxG,MAAM,IAAI/C,KAAK,CAAC,4BAA4B0F,SAAS,GAAG,IAAIA,SAAS,IAAI,GAAG,EAAE,4BAA4BlC,SAAS,oBAAoB,IAAI,CAACpC,EAAE,OAAOqE,GAAG,CAACE,OAAO,EAAE,CAAC;MACrK;MACA,IAAIH,WAAW,EAAE;QACfjC,OAAO,CAACuB,IAAI,CAAC,GAAGM,SAAS,CAAC7B,OAAO,CAAC;QAClC2B,kBAAkB,GAAGE,SAAS;QAC9B;MACF;IACF;IACA,OAAOF,kBAAkB,GAAG,CAACA,kBAAkB,CAAC,GAAGnC,SAAS;EAC9D;;EAEA;EACA,IAAI6C,MAAMA,CAAA,EAAG;IACX,OAAOvF,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,MAAM;MAChC,MAAM;QACJiB;MACF,CAAC,GAAG,IAAI;MACR,MAAMsE,MAAM,GAAG,IAAIC,GAAG,CAAC,IAAI,CAACC,SAAS,CAAC;MACtC,IAAIxE,MAAM,EAAE;QACV,KAAK,MAAMyE,OAAO,IAAIxD,MAAM,CAACC,IAAI,CAAClB,MAAM,CAAC,EAAE;UACzC,MAAMqC,KAAK,GAAGrC,MAAM,CAACyE,OAAO,CAAC;UAC7B,IAAIpC,KAAK,CAACrC,MAAM,EAAE;YAChB,KAAK,MAAM7B,KAAK,IAAIkE,KAAK,CAACiC,MAAM,EAAE;cAChCA,MAAM,CAACI,GAAG,CAAC,GAAGvG,KAAK,EAAE,CAAC;YACxB;UACF;QACF;MACF;MACA,OAAOwG,KAAK,CAACC,IAAI,CAACN,MAAM,CAAC;IAC3B,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIE,SAASA,CAAA,EAAG;IACd,MAAMF,MAAM,GAAG,IAAIC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC5D,WAAW,CAACO,IAAI,CAAC,CAAC,CAAC,CAAC2D,MAAM,CAACzB,UAAU,IAAI;MACvE,OAAO,IAAI,CAACzC,WAAW,CAACvB,GAAG,CAACgE,UAAU,CAAC,CAAC0B,IAAI,CAACvB,UAAU,IAAI,EAAE,CAACA,UAAU,CAACxB,MAAM,IAAI,CAACwB,UAAU,CAACtB,OAAO,CAACzD,MAAM,IAAI,CAAC+E,UAAU,CAACpB,OAAO,CAAC,CAAC;IACxI,CAAC,CAAC,CAAC;IACH,OAAOwC,KAAK,CAACC,IAAI,CAACN,MAAM,CAAC;EAC3B;AACF;AAEA,MAAMS,gBAAgB,GAAG,GAAG;AAC5B,MAAMC,YAAY,CAAC;EACjBrF,WAAWA,CAAC;EACZC,MAAM,EAAEqF,eAAe,EAAE;IACvB,IAAI,CAACrF,MAAM,GAAGA,MAAM;IACpB;IACA,IAAI,CAACkC,OAAO,GAAG,KAAK,CAAC;IACrB,IAAI,CAACoD,OAAO,GAAG,KAAK,CAAC;IACrB,IAAI,CAACD,eAAe,GAAG,KAAK,CAAC;IAC7B;IACA,IAAI,CAACE,YAAY,GAAG,IAAI;IACxB;IACA,IAAI,CAAChE,KAAK,GAAG,IAAIiE,GAAG,CAAC,CAAC;IACtB,IAAI,CAACC,IAAI,GAAG,KAAK,CAAC;IAClB,IAAI,CAACvF,EAAE,GAAG,KAAK,CAAC;IAChB,IAAI,CAACE,MAAM,GAAG,KAAK,CAAC;IACpB,IAAI,CAACsE,MAAM,GAAG,KAAK,CAAC;IACpB,IAAI,CAACxE,EAAE,GAAGF,MAAM,CAACE,EAAE,IAAI,WAAW;IAClC,IAAI,CAACmF,eAAe,GAAG;MACrBK,MAAM,EAAEL,eAAe,EAAEK,MAAM,IAAI,CAAC,CAAC;MACrCrD,OAAO,EAAEgD,eAAe,EAAEhD,OAAO,IAAI,CAAC,CAAC;MACvCsD,MAAM,EAAEN,eAAe,EAAEM,MAAM,IAAI,CAAC,CAAC;MACrCC,MAAM,EAAEP,eAAe,EAAEO,MAAM,IAAI,CAAC;IACtC,CAAC;IACD,IAAI,CAAC1D,OAAO,GAAG,IAAI,CAAClC,MAAM,CAACkC,OAAO;IAClC,IAAI,CAACoD,OAAO,GAAG,IAAI,CAACtF,MAAM,CAACsF,OAAO;IAClC,IAAI,CAAC3B,UAAU,GAAG,IAAI,CAACA,UAAU,CAACkC,IAAI,CAAC,IAAI,CAAC;IAC5C,IAAI,CAACC,kBAAkB,GAAG,IAAI,CAACA,kBAAkB,CAACD,IAAI,CAAC,IAAI,CAAC;IAC5D,IAAI,CAACtK,oBAAoB,GAAG,IAAI,CAACA,oBAAoB,CAACsK,IAAI,CAAC,IAAI,CAAC;IAChE,IAAI,CAACE,eAAe,GAAG,IAAI,CAACA,eAAe,CAACF,IAAI,CAAC,IAAI,CAAC;IACtD,IAAI,CAACG,KAAK,GAAG,IAAI,CAACA,KAAK,CAACH,IAAI,CAAC,IAAI,CAAC;IAClC,IAAI,CAACJ,IAAI,GAAG,IAAI3F,SAAS,CAACE,MAAM,EAAE;MAChCkB,IAAI,EAAE,IAAI,CAAChB,EAAE;MACbiB,QAAQ,EAAE;IACZ,CAAC,CAAC;IACF,IAAI,CAACsE,IAAI,CAAC3D,WAAW,CAAC,CAAC;IACvB,IAAI,CAAC1B,MAAM,GAAG,IAAI,CAACqF,IAAI,CAACrF,MAAM,CAAC,CAAC;IAChC,IAAI,CAACsE,MAAM,GAAG,IAAI,CAACe,IAAI,CAACf,MAAM;EAChC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEuB,OAAOA,CAACZ,eAAe,EAAE;IACvB,MAAM;MACJhD,OAAO;MACPuD,MAAM;MACNF,MAAM;MACNC;IACF,CAAC,GAAG,IAAI,CAACN,eAAe;IACxB,OAAO,IAAID,YAAY,CAAC,IAAI,CAACpF,MAAM,EAAE;MACnCqC,OAAO,EAAE;QACP,GAAGA,OAAO;QACV,GAAGgD,eAAe,CAAChD;MACrB,CAAC;MACDuD,MAAM,EAAE;QACN,GAAGA,MAAM;QACT,GAAGP,eAAe,CAACO;MACrB,CAAC;MACDF,MAAM,EAAE;QACN,GAAGA,MAAM;QACT,GAAGL,eAAe,CAACK;MACrB,CAAC;MACDC,MAAM,EAAE;QACN,GAAGA,MAAM;QACT,GAAGN,eAAe,CAACM;MACrB;IACF,CAAC,CAAC;EACJ;EACAO,YAAYA,CAAClG,MAAM,EAAE;IACnB,MAAMmG,kBAAkB,GAAGxM,iBAAiB,CAAC,IAAI,CAAC8L,IAAI,EAAEzF,MAAM,CAACoG,KAAK,CAAC;IACrE,MAAMC,OAAO,GAAGxM,gBAAgB,CAACE,aAAa,CAAC,IAAI,CAAC0L,IAAI,EAAEU,kBAAkB,CAAC,CAAC;IAC9E,OAAOlM,qBAAqB,CAAC;MAC3BqM,MAAM,EAAE,CAAC,GAAGD,OAAO,CAAC;MACpBhC,OAAO,EAAErE,MAAM,CAACqE,OAAO,IAAI,CAAC,CAAC;MAC7BkC,QAAQ,EAAE,CAAC,CAAC;MACZC,MAAM,EAAErM,cAAc,CAACkM,OAAO,EAAE,IAAI,CAACZ,IAAI,CAAC,GAAG,MAAM,GAAGzF,MAAM,CAACwG,MAAM,IAAI,QAAQ;MAC/E7F,MAAM,EAAEX,MAAM,CAACW,MAAM;MACrB8F,KAAK,EAAEzG,MAAM,CAACyG,KAAK;MACnBC,YAAY,EAAE1G,MAAM,CAAC0G;IACvB,CAAC,EAAE,IAAI,CAAC;EACV;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE/C,UAAUA,CAACI,QAAQ,EAAExF,KAAK,EAAEoI,UAAU,EAAE;IACtC,OAAOtM,SAAS,CAAC0J,QAAQ,EAAExF,KAAK,EAAEoI,UAAU,CAAC,CAAC5C,QAAQ;EACxD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACElJ,SAASA,CAACkJ,QAAQ,EAAExF,KAAK,EAAEoI,UAAU,EAAE;IACrC,OAAOtM,SAAS,CAAC0J,QAAQ,EAAExF,KAAK,EAAEoI,UAAU,CAAC,CAACC,WAAW;EAC3D;EACAC,iBAAiBA,CAAC9C,QAAQ,EAAExF,KAAK,EAAE;IACjC,OAAOhE,cAAc,CAAC,IAAI,CAACkL,IAAI,EAAE1B,QAAQ,CAACqC,KAAK,EAAErC,QAAQ,EAAExF,KAAK,CAAC,IAAI,EAAE;EACzE;;EAEA;AACF;AACA;AACA;EACEuI,kBAAkBA,CAACH,UAAU,EAAEI,SAAS,EAAEC,aAAa,EAAE;IACvD,MAAM;MACJ3C;IACF,CAAC,GAAG,IAAI,CAACrE,MAAM;IACf,MAAMiH,UAAU,GAAGhN,qBAAqB,CAAC;MACvCoK,OAAO,EAAE,OAAOA,OAAO,KAAK,UAAU,IAAIA,OAAO,GAAGA,OAAO,GAAG,CAAC,CAAC;MAChEiC,MAAM,EAAE,CAAC,IAAI,CAACb,IAAI,CAAC;MACnBc,QAAQ,EAAE,CAAC,CAAC;MACZC,MAAM,EAAE;IACV,CAAC,EAAE,IAAI,CAAC;IACR,IAAI,OAAOnC,OAAO,KAAK,UAAU,EAAE;MACjC,MAAM6C,UAAU,GAAGC,KAAA;QAAA,IAAC;UAClBC,KAAK;UACL7I,KAAK;UACL8I;QACF,CAAC,GAAAF,KAAA;QAAA,OAAK9C,OAAO,CAAC;UACZ+C,KAAK;UACLE,KAAK,EAAE/I,KAAK,CAAC+I,KAAK;UAClBD;QACF,CAAC,CAAC;MAAA;MACF,OAAO5M,wBAAwB,CAACwM,UAAU,EAAEF,SAAS,EAAEJ,UAAU,EAAE,CAAC7I,MAAM,CAACoJ,UAAU,CAAC,CAAC,EAAEF,aAAa,CAAC;IACzG;IACA,OAAOC,UAAU;EACnB;;EAEA;AACF;AACA;AACA;EACEnB,kBAAkBA,CAACa,UAAU,EAAEW,KAAK,EAAE;IACpC,MAAMP,SAAS,GAAGpM,eAAe,CAAC2M,KAAK,CAAC,CAAC,CAAC;IAC1C,MAAMN,aAAa,GAAG,EAAE;IACxB,MAAMO,eAAe,GAAG,IAAI,CAACT,kBAAkB,CAACH,UAAU,EAAEI,SAAS,EAAEC,aAAa,CAAC;IACrF,MAAMQ,SAAS,GAAG3M,SAAS,CAAC,CAAC;MAC3BsH,MAAM,EAAE,CAAC,GAAGpH,oBAAoB,CAAC,IAAI,CAAC0K,IAAI,CAAC,CAAC;MAC5CrD,MAAM,EAAE,IAAI,CAACqD,IAAI;MACjBlD,OAAO,EAAE,IAAI;MACbF,OAAO,EAAE,EAAE;MACXC,SAAS,EAAE,IAAI;MACfE,MAAM,EAAE,IAAI,CAAC;IACf,CAAC,CAAC,EAAE+E,eAAe,EAAEZ,UAAU,EAAEI,SAAS,EAAE,IAAI,EAAEC,aAAa,CAAC;IAChE,MAAM;MACJjD,QAAQ,EAAE0D;IACZ,CAAC,GAAGpN,SAAS,CAACmN,SAAS,EAAET,SAAS,EAAEJ,UAAU,EAAEK,aAAa,CAAC;IAC9D,OAAOS,UAAU;EACnB;EACAzB,KAAKA,CAACjC,QAAQ,EAAE;IACd1C,MAAM,CAACsB,MAAM,CAACoB,QAAQ,CAACwC,QAAQ,CAAC,CAACvE,OAAO,CAAC0F,KAAK,IAAI;MAChD,IAAIA,KAAK,CAACC,WAAW,CAAC,CAAC,CAACnB,MAAM,KAAK,QAAQ,EAAE;QAC3CkB,KAAK,CAAC1B,KAAK,CAAC,CAAC;MACf;IACF,CAAC,CAAC;EACJ;EACA4B,gBAAgBA,CAAC/C,OAAO,EAAE;IACxB,MAAMgD,QAAQ,GAAG5M,WAAW,CAAC4J,OAAO,CAAC;IACrC,MAAMiD,YAAY,GAAGD,QAAQ,CAACjG,KAAK,CAAC,CAAC,CAAC;IACtC,MAAMmG,eAAe,GAAG5M,SAAS,CAAC0M,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC,CAACjG,KAAK,CAACuD,gBAAgB,CAACvG,MAAM,CAAC,GAAGiJ,QAAQ,CAAC,CAAC,CAAC;IACzG,MAAMnG,SAAS,GAAG,IAAI,CAACH,KAAK,CAAC/B,GAAG,CAACuI,eAAe,CAAC;IACjD,IAAI,CAACrG,SAAS,EAAE;MACd,MAAM,IAAI5C,KAAK,CAAC,sBAAsBiJ,eAAe,gCAAgC,IAAI,CAAC7H,EAAE,GAAG,CAAC;IAClG;IACA,OAAO7E,kBAAkB,CAACqG,SAAS,EAAEoG,YAAY,CAAC;EACpD;EACA,IAAI7F,UAAUA,CAAA,EAAG;IACf,OAAO,IAAI,CAACwD,IAAI,CAACxD,UAAU;EAC7B;EACAO,MAAMA,CAAA,EAAG;IACP,OAAO,IAAI,CAACP,UAAU;EACxB;EACA1G,oBAAoBA,CAACwI,QAAQ,EAAE9D,OAAO,EAAE;IACtC,OAAO1E,oBAAoB,CAACwI,QAAQ,EAAE9D,OAAO,CAAC;EAChD;EACA8F,eAAeA,CAAChC,QAAQ,EAAEiE,WAAW,EAAE;IACrC,MAAMzB,QAAQ,GAAG,CAAC,CAAC;IACnB,MAAM0B,gBAAgB,GAAGlE,QAAQ,CAACwC,QAAQ;IAC1ClF,MAAM,CAACC,IAAI,CAAC2G,gBAAgB,CAAC,CAACjG,OAAO,CAACkG,OAAO,IAAI;MAC/C,MAAMC,SAAS,GAAGF,gBAAgB,CAACC,OAAO,CAAC;MAC3C,MAAME,UAAU,GAAGD,SAAS,CAACpE,QAAQ;MACrC,MAAMhB,GAAG,GAAGoF,SAAS,CAACpF,GAAG;MACzB,MAAMsF,KAAK,GAAG,OAAOtF,GAAG,KAAK,QAAQ,GAAGtH,sBAAsB,CAAC,IAAI,EAAEsH,GAAG,CAAC,GAAGA,GAAG;MAC/E,IAAI,CAACsF,KAAK,EAAE;QACV;MACF;MACA,MAAMC,QAAQ,GAAG3M,WAAW,CAAC0M,KAAK,EAAE;QAClCnI,EAAE,EAAEgI,OAAO;QACX1H,MAAM,EAAEwH,WAAW,CAACX,IAAI;QACxBkB,YAAY,EAAEJ,SAAS,CAACI,YAAY;QACpCxE,QAAQ,EAAEqE,UAAU;QACpBrF,GAAG;QACHC,QAAQ,EAAEmF,SAAS,CAACnF;MACtB,CAAC,CAAC;MACFuD,QAAQ,CAAC2B,OAAO,CAAC,GAAGI,QAAQ;IAC9B,CAAC,CAAC;IACF,MAAME,gBAAgB,GAAGvO,qBAAqB,CAAC;MAC7C,GAAG8J,QAAQ;MACXwC,QAAQ;MACRD,MAAM,EAAEvB,KAAK,CAACC,IAAI,CAACnL,gBAAgB,CAACE,aAAa,CAAC,IAAI,CAAC0L,IAAI,EAAE1B,QAAQ,CAACqC,KAAK,CAAC,CAAC;IAC/E,CAAC,EAAE,IAAI,CAAC;IACR,IAAIqC,IAAI,GAAG,IAAI9D,GAAG,CAAC,CAAC;IACpB,SAAS+D,aAAaA,CAACC,WAAW,EAAEpC,QAAQ,EAAE;MAC5C,IAAIkC,IAAI,CAACG,GAAG,CAACD,WAAW,CAAC,EAAE;QACzB;MACF;MACAF,IAAI,CAAC3D,GAAG,CAAC6D,WAAW,CAAC;MACrB,KAAK,IAAItJ,GAAG,IAAIsJ,WAAW,EAAE;QAC3B,MAAMvC,KAAK,GAAGuC,WAAW,CAACtJ,GAAG,CAAC;QAC9B,IAAI+G,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;UACtC,IAAI,cAAc,IAAIA,KAAK,IAAIA,KAAK,CAACyC,YAAY,KAAKhN,YAAY,EAAE;YAClE8M,WAAW,CAACtJ,GAAG,CAAC,GAAGkH,QAAQ,CAACH,KAAK,CAAClG,EAAE,CAAC;YACrC;UACF;UACAwI,aAAa,CAACtC,KAAK,EAAEG,QAAQ,CAAC;QAChC;MACF;IACF;IACAmC,aAAa,CAACF,gBAAgB,CAACnE,OAAO,EAAEkC,QAAQ,CAAC;IACjD,OAAOiC,gBAAgB;EACzB;AACF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,aAAaA,CAAC9I,MAAM,EAAEqF,eAAe,EAAE;EAC9C,OAAO,IAAID,YAAY,CAACpF,MAAM,EAAEqF,eAAe,CAAC;AAClD;;AAEA;AACA,SAAS0D,qBAAqBA,CAACC,UAAU,EAAE;EACzC,MAAM3B,IAAI,GAAG1L,WAAW,CAACqN,UAAU,CAAC;EACpC,MAAMC,eAAe,GAAG;IACtB5B,IAAI;IACJ6B,KAAK,EAAEA,CAAA,KAAM,CAAC,CAAC;IACfhJ,EAAE,EAAE,EAAE;IACNiJ,MAAM,EAAEA,CAAA,KAAM,CAAC,CAAC;IAChBC,SAAS,EAAE,EAAE;IACbzL,SAAS,EAAEA,CAAA,KAAM,CAAC,CAAC;IACnB0L,MAAM,EAAEhC,IAAI,CAACgC,MAAM;IACnBrL,IAAI,EAAEA,CAAA,KAAM,CAAC;EACf,CAAC;EACD,OAAOiL,eAAe;AACxB;AACA,SAASnD,kBAAkBA,CAACkD,UAAU,EAAc;EAAA,SAAAM,IAAA,GAAAC,SAAA,CAAA3K,MAAA,EAAA4K,KAAA,OAAAzE,KAAA,CAAAuE,IAAA,OAAAA,IAAA,WAAApI,IAAA,MAAAA,IAAA,GAAAoI,IAAA,EAAApI,IAAA;IAAAsI,KAAA,CAAAtI,IAAA,QAAAqI,SAAA,CAAArI,IAAA;EAAA;EAAA,IAAT,CAACoG,KAAK,CAAC,GAAAkC,KAAA;EAChD,MAAM7C,UAAU,GAAGoC,qBAAqB,CAACC,UAAU,CAAC;EACpD,OAAOA,UAAU,CAAClD,kBAAkB,CAACa,UAAU,EAAEW,KAAK,CAAC;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmC,eAAeA,CAACT,UAAU,EAAEjF,QAAQ,EAAExF,KAAK,EAAE;EACpD,MAAM0K,eAAe,GAAGF,qBAAqB,CAACC,UAAU,CAAC;EACzDC,eAAe,CAAC5B,IAAI,CAACqC,SAAS,GAAG3F,QAAQ;EACzC,OAAOiF,UAAU,CAACrF,UAAU,CAACI,QAAQ,EAAExF,KAAK,EAAE0K,eAAe,CAAC;AAChE;;AAEA;AACA;;AAEA,SAASU,KAAKA,CAAAC,KAAA,EAMX;EAAA,IANY;IACbtE,OAAO;IACPI,MAAM;IACNrD,OAAO;IACPuD,MAAM;IACND;EACF,CAAC,GAAAiE,KAAA;EACC,OAAO;IACLd,aAAa,EAAE9I,MAAM,IAAI8I,aAAa,CAAC;MACrC,GAAG9I,MAAM;MACTsF;IACF,CAAC,EAAE;MACDI,MAAM;MACNrD,OAAO;MACPuD,MAAM;MACND;IACF,CAAC;EACH,CAAC;AACH;AAEA,MAAMkE,cAAc,CAAC;EACnB9J,WAAWA,CAAA,EAAG;IACZ,IAAI,CAAC+J,QAAQ,GAAG,IAAItE,GAAG,CAAC,CAAC;IACzB,IAAI,CAACuE,IAAI,GAAG,CAAC;IACb,IAAI,CAACC,GAAG,GAAG,CAAC;IACZ,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,oBAAoB,GAAG,KAAK;EACnC;EACAC,GAAGA,CAAA,EAAG;IACJ,OAAO,IAAI,CAACJ,IAAI;EAClB;EACAK,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI,CAACJ,GAAG,EAAE;EACnB;EACAK,UAAUA,CAAC/K,EAAE,EAAEgL,OAAO,EAAE;IACtB,IAAI,CAACJ,oBAAoB,GAAG,IAAI,CAACD,SAAS;IAC1C,MAAM/J,EAAE,GAAG,IAAI,CAACkK,KAAK,CAAC,CAAC;IACvB,IAAI,CAACN,QAAQ,CAACrK,GAAG,CAACS,EAAE,EAAE;MACpB8F,KAAK,EAAE,IAAI,CAACmE,GAAG,CAAC,CAAC;MACjBG,OAAO;MACPhL;IACF,CAAC,CAAC;IACF,OAAOY,EAAE;EACX;EACAqK,YAAYA,CAACrK,EAAE,EAAE;IACf,IAAI,CAACgK,oBAAoB,GAAG,IAAI,CAACD,SAAS;IAC1C,IAAI,CAACH,QAAQ,CAACU,MAAM,CAACtK,EAAE,CAAC;EAC1B;EACAT,GAAGA,CAACgL,IAAI,EAAE;IACR,IAAI,IAAI,CAACV,IAAI,GAAGU,IAAI,EAAE;MACpB,MAAM,IAAI3L,KAAK,CAAC,+BAA+B,CAAC;IAClD;IACA,IAAI,CAACiL,IAAI,GAAGU,IAAI;IAChB,IAAI,CAACC,aAAa,CAAC,CAAC;EACtB;EACAA,aAAaA,CAAA,EAAG;IACd,IAAI,IAAI,CAACT,SAAS,EAAE;MAClB,IAAI,CAACC,oBAAoB,GAAG,IAAI;MAChC;IACF;IACA,IAAI,CAACD,SAAS,GAAG,IAAI;IACrB,MAAMU,MAAM,GAAG,CAAC,GAAG,IAAI,CAACb,QAAQ,CAAC,CAACc,IAAI,CAAC,CAAAC,KAAA,EAAAC,KAAA,KAAwC;MAAA,IAAvC,CAACC,IAAI,EAAEC,QAAQ,CAAC,GAAAH,KAAA;MAAA,IAAE,CAACI,IAAI,EAAEC,QAAQ,CAAC,GAAAJ,KAAA;MACxE,MAAMK,IAAI,GAAGH,QAAQ,CAAChF,KAAK,GAAGgF,QAAQ,CAACV,OAAO;MAC9C,MAAMc,IAAI,GAAGF,QAAQ,CAAClF,KAAK,GAAGkF,QAAQ,CAACZ,OAAO;MAC9C,OAAOc,IAAI,GAAGD,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC;IAC7B,CAAC,CAAC;IACF,KAAK,MAAM,CAACjL,EAAE,EAAEoK,OAAO,CAAC,IAAIK,MAAM,EAAE;MAClC,IAAI,IAAI,CAACT,oBAAoB,EAAE;QAC7B,IAAI,CAACA,oBAAoB,GAAG,KAAK;QACjC,IAAI,CAACD,SAAS,GAAG,KAAK;QACtB,IAAI,CAACS,aAAa,CAAC,CAAC;QACpB;MACF;MACA,IAAI,IAAI,CAACP,GAAG,CAAC,CAAC,GAAGG,OAAO,CAACtE,KAAK,IAAIsE,OAAO,CAACA,OAAO,EAAE;QACjD,IAAI,CAACR,QAAQ,CAACU,MAAM,CAACtK,EAAE,CAAC;QACxBoK,OAAO,CAAChL,EAAE,CAAC+L,IAAI,CAAC,IAAI,CAAC;MACvB;IACF;IACA,IAAI,CAACpB,SAAS,GAAG,KAAK;EACxB;EACAqB,SAASA,CAACC,EAAE,EAAE;IACZ,IAAI,CAACxB,IAAI,IAAIwB,EAAE;IACf,IAAI,CAACb,aAAa,CAAC,CAAC;EACtB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASc,SAASA,CAACC,KAAK,EAAE;EACxB,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtCH,KAAK,CAACI,SAAS,CAAC;MACdC,QAAQ,EAAEA,CAAA,KAAM;QACdH,OAAO,CAACF,KAAK,CAAC9D,WAAW,CAAC,CAAC,CAAChH,MAAM,CAAC;MACrC,CAAC;MACD8F,KAAK,EAAEmF;IACT,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AAEA,MAAMG,qBAAqB,GAAG;EAC5BzB,OAAO,EAAE0B,QAAQ,CAAC;AACpB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,OAAOA,CAAC3D,QAAQ,EAAE4D,SAAS,EAAEjM,OAAO,EAAE;EAC7C,MAAMkM,eAAe,GAAG;IACtB,GAAGJ,qBAAqB;IACxB,GAAG9L;EACL,CAAC;EACD,OAAO,IAAIyL,OAAO,CAAC,CAACU,GAAG,EAAEC,GAAG,KAAK;IAC/B,MAAM;MACJC;IACF,CAAC,GAAGH,eAAe;IACnB,IAAIG,MAAM,EAAEC,OAAO,EAAE;MACnBF,GAAG,CAACC,MAAM,CAACE,MAAM,CAAC;MAClB;IACF;IACA,IAAIC,IAAI,GAAG,KAAK;IAChB,MAAMC,MAAM,GAAGP,eAAe,CAAC7B,OAAO,KAAK0B,QAAQ,GAAGnK,SAAS,GAAGwI,UAAU,CAAC,MAAM;MACjFsC,OAAO,CAAC,CAAC;MACTN,GAAG,CAAC,IAAIvN,KAAK,CAAC,cAAcqN,eAAe,CAAC7B,OAAO,cAAc,CAAC,CAAC;IACrE,CAAC,EAAE6B,eAAe,CAAC7B,OAAO,CAAC;IAC3B,MAAMqC,OAAO,GAAGA,CAAA,KAAM;MACpBpC,YAAY,CAACmC,MAAM,CAAC;MACpBD,IAAI,GAAG,IAAI;MACXG,GAAG,EAAEC,WAAW,CAAC,CAAC;MAClB,IAAIC,aAAa,EAAE;QACjBR,MAAM,CAACS,mBAAmB,CAAC,OAAO,EAAED,aAAa,CAAC;MACpD;IACF,CAAC;IACD,SAASE,YAAYA,CAACC,OAAO,EAAE;MAC7B,IAAIf,SAAS,CAACe,OAAO,CAAC,EAAE;QACtBN,OAAO,CAAC,CAAC;QACTP,GAAG,CAACa,OAAO,CAAC;MACd;IACF;;IAEA;AACJ;AACA;AACA;IACI,IAAIH,aAAa;IACjB,IAAIF,GAAG,CAAC,CAAC;;IAET;IACAI,YAAY,CAAC1E,QAAQ,CAACX,WAAW,CAAC,CAAC,CAAC;IACpC,IAAI8E,IAAI,EAAE;MACR;IACF;;IAEA;IACA,IAAIH,MAAM,EAAE;MACVQ,aAAa,GAAGA,CAAA,KAAM;QACpBH,OAAO,CAAC,CAAC;QACT;QACAN,GAAG,CAACC,MAAM,CAACE,MAAM,CAAC;MACpB,CAAC;MACDF,MAAM,CAACY,gBAAgB,CAAC,OAAO,EAAEJ,aAAa,CAAC;IACjD;IACAF,GAAG,GAAGtE,QAAQ,CAACuD,SAAS,CAAC;MACvB/H,IAAI,EAAEkJ,YAAY;MAClBvG,KAAK,EAAElC,GAAG,IAAI;QACZoI,OAAO,CAAC,CAAC;QACTN,GAAG,CAAC9H,GAAG,CAAC;MACV,CAAC;MACDuH,QAAQ,EAAEA,CAAA,KAAM;QACda,OAAO,CAAC,CAAC;QACTN,GAAG,CAAC,IAAIvN,KAAK,CAAC,+CAA+C,CAAC,CAAC;MACjE;IACF,CAAC,CAAC;IACF,IAAI2N,IAAI,EAAE;MACRG,GAAG,CAACC,WAAW,CAAC,CAAC;IACnB;EACF,CAAC,CAAC;AACJ;AAEA,SAAShD,cAAc,EAAEzE,YAAY,EAAEtF,SAAS,EAAExB,WAAW,EAAEwK,aAAa,EAAEhD,kBAAkB,EAAE2D,eAAe,EAAEE,KAAK,EAAE6B,SAAS,EAAES,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}