{"ast":null,"code":"import { T as ProcessingStatus, z as resolveReferencedActor, A as createActor, U as cloneMachineSnapshot, V as XSTATE_ERROR, W as createErrorActorEvent, e as evaluateGuard, M as cancel, O as raise, P as spawnChild, R as stopChild } from './raise-0f7cf128.esm.js';\nfunction createSpawner(actorScope, _ref, event, spawnedChildren) {\n  let {\n    machine,\n    context\n  } = _ref;\n  const spawn = function (src) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      systemId,\n      input\n    } = options;\n    if (typeof src === 'string') {\n      const logic = resolveReferencedActor(machine, src);\n      if (!logic) {\n        throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);\n      }\n      const actorRef = createActor(logic, {\n        id: options.id,\n        parent: actorScope.self,\n        syncSnapshot: options.syncSnapshot,\n        input: typeof input === 'function' ? input({\n          context,\n          event,\n          self: actorScope.self\n        }) : input,\n        src,\n        systemId\n      });\n      spawnedChildren[actorRef.id] = actorRef;\n      return actorRef;\n    } else {\n      const actorRef = createActor(src, {\n        id: options.id,\n        parent: actorScope.self,\n        syncSnapshot: options.syncSnapshot,\n        input: options.input,\n        src,\n        systemId\n      });\n      return actorRef;\n    }\n  };\n  return (src, options) => {\n    const actorRef = spawn(src, options); // TODO: fix types\n    spawnedChildren[actorRef.id] = actorRef;\n    actorScope.defer(() => {\n      if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n        return;\n      }\n      actorRef.start();\n    });\n    return actorRef;\n  };\n}\nfunction resolveAssign(actorScope, snapshot, actionArgs, actionParams, _ref2) {\n  let {\n    assignment\n  } = _ref2;\n  if (!snapshot.context) {\n    throw new Error('Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.');\n  }\n  const spawnedChildren = {};\n  const assignArgs = {\n    context: snapshot.context,\n    event: actionArgs.event,\n    spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),\n    self: actorScope.self,\n    system: actorScope.system\n  };\n  let partialUpdate = {};\n  if (typeof assignment === 'function') {\n    partialUpdate = assignment(assignArgs, actionParams);\n  } else {\n    for (const key of Object.keys(assignment)) {\n      const propAssignment = assignment[key];\n      partialUpdate[key] = typeof propAssignment === 'function' ? propAssignment(assignArgs, actionParams) : propAssignment;\n    }\n  }\n  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n  return [cloneMachineSnapshot(snapshot, {\n    context: updatedContext,\n    children: Object.keys(spawnedChildren).length ? {\n      ...snapshot.children,\n      ...spawnedChildren\n    } : snapshot.children\n  })];\n}\n/**\n * Updates the current context of the machine.\n *\n * @example\n *\n * ```ts\n * import { createMachine, assign } from 'xstate';\n *\n * const countMachine = createMachine({\n *   context: {\n *     count: 0,\n *     message: ''\n *   },\n *   on: {\n *     inc: {\n *       actions: assign({\n *         count: ({ context }) => context.count + 1\n *       })\n *     },\n *     updateMessage: {\n *       actions: assign(({ context, event }) => {\n *         return {\n *           message: event.message.trim()\n *         };\n *       })\n *     }\n *   }\n * });\n * ```\n *\n * @param assignment An object that represents the partial context to update, or\n *   a function that returns an object that represents the partial context to\n *   update.\n */\nfunction assign(assignment) {\n  function assign(args, params) {}\n  assign.type = 'xstate.assign';\n  assign.assignment = assignment;\n  assign.resolve = resolveAssign;\n  return assign;\n}\nfunction resolveEmit(_, snapshot, args, actionParams, _ref3) {\n  let {\n    event: eventOrExpr\n  } = _ref3;\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  return [snapshot, {\n    event: resolvedEvent\n  }];\n}\nfunction executeEmit(actorScope, _ref4) {\n  let {\n    event\n  } = _ref4;\n  actorScope.defer(() => actorScope.emit(event));\n}\n/**\n * Emits an event to event handlers registered on the actor via `actor.on(event,\n * handler)`.\n *\n * @example\n *\n * ```ts\n * import { emit } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     something: {\n *       actions: emit({\n *         type: 'emitted',\n *         some: 'data'\n *       })\n *     }\n *   }\n *   // ...\n * });\n *\n * const actor = createActor(machine).start();\n *\n * actor.on('emitted', (event) => {\n *   console.log(event);\n * });\n *\n * actor.send({ type: 'something' });\n * // logs:\n * // {\n * //   type: 'emitted',\n * //   some: 'data'\n * // }\n * ```\n */\nfunction emit(/** The event to emit, or an expression that returns an event to emit. */\neventOrExpr) {\n  function emit(args, params) {}\n  emit.type = 'xstate.emit';\n  emit.event = eventOrExpr;\n  emit.resolve = resolveEmit;\n  emit.execute = executeEmit;\n  return emit;\n}\n\n/**\n * @remarks\n * `T | unknown` reduces to `unknown` and that can be problematic when it comes\n * to contextual typing. It especially is a problem when the union has a\n * function member, like here:\n *\n * ```ts\n * declare function test(\n *   cbOrVal: ((arg: number) => unknown) | unknown\n * ): void;\n * test((arg) => {}); // oops, implicit any\n * ```\n *\n * This type can be used to avoid this problem. This union represents the same\n * value space as `unknown`.\n */\n\n// https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887\n\n// @TODO: Replace with native `NoInfer` when TS issue gets fixed:\n// https://github.com/microsoft/TypeScript/pull/57673\n\n/** @deprecated Use the built-in `NoInfer` type instead */\n\n/** The full definition of an event, with a string `type`. */\n\n/**\n * The string or object representing the state value relative to the parent\n * state node.\n *\n * @remarks\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\n * - For complex state nodes, this is an object, e.g., `{ success:\n *   \"someChildState\" }`.\n */\n\n// TODO: remove once TS fixes this type-widening issue\n\n/** @deprecated Use `AnyMachineSnapshot` instead */\n\n// TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something\n/** @ignore */\n\nlet SpecialTargets = /*#__PURE__*/function (SpecialTargets) {\n  SpecialTargets[\"Parent\"] = \"#_parent\";\n  SpecialTargets[\"Internal\"] = \"#_internal\";\n  return SpecialTargets;\n}({});\n\n/** @deprecated Use `AnyActor` instead. */\n\n// Based on RxJS types\n\n// TODO: in v6, this should only accept AnyActorLogic, like ActorRefFromLogic\n\n/** @deprecated Use `Actor<T>` instead. */\n\n/**\n * Represents logic which can be used by an actor.\n *\n * @template TSnapshot - The type of the snapshot.\n * @template TEvent - The type of the event object.\n * @template TInput - The type of the input.\n * @template TSystem - The type of the actor system.\n */\n\n/** @deprecated */\n\nfunction resolveSendTo(actorScope, snapshot, args, actionParams, _ref5, extra) {\n  let {\n    to,\n    event: eventOrExpr,\n    id,\n    delay\n  } = _ref5;\n  const delaysMap = snapshot.machine.implementations.delays;\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(`Only event objects may be used with sendTo; use sendTo({ type: \"${eventOrExpr}\" }) instead`);\n  }\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  let resolvedDelay;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay = typeof configDelay === 'function' ? configDelay(args, actionParams) : configDelay;\n  } else {\n    resolvedDelay = typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n  const resolvedTarget = typeof to === 'function' ? to(args, actionParams) : to;\n  let targetActorRef;\n  if (typeof resolvedTarget === 'string') {\n    if (resolvedTarget === SpecialTargets.Parent) {\n      targetActorRef = actorScope.self._parent;\n    } else if (resolvedTarget === SpecialTargets.Internal) {\n      targetActorRef = actorScope.self;\n    } else if (resolvedTarget.startsWith('#_')) {\n      // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor\n      // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.\n      targetActorRef = snapshot.children[resolvedTarget.slice(2)];\n    } else {\n      targetActorRef = extra.deferredActorIds?.includes(resolvedTarget) ? resolvedTarget : snapshot.children[resolvedTarget];\n    }\n    if (!targetActorRef) {\n      throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`);\n    }\n  } else {\n    targetActorRef = resolvedTarget || actorScope.self;\n  }\n  return [snapshot, {\n    to: targetActorRef,\n    event: resolvedEvent,\n    id,\n    delay: resolvedDelay\n  }];\n}\nfunction retryResolveSendTo(_, snapshot, params) {\n  if (typeof params.to === 'string') {\n    params.to = snapshot.children[params.to];\n  }\n}\nfunction executeSendTo(actorScope, params) {\n  // this forms an outgoing events queue\n  // thanks to that the recipient actors are able to read the *updated* snapshot value of the sender\n  actorScope.defer(() => {\n    const {\n      to,\n      event,\n      delay,\n      id\n    } = params;\n    if (typeof delay === 'number') {\n      actorScope.system.scheduler.schedule(actorScope.self, to, event, delay, id);\n      return;\n    }\n    actorScope.system._relay(actorScope.self,\n    // at this point, in a deferred task, it should already be mutated by retryResolveSendTo\n    // if it initially started as a string\n    to, event.type === XSTATE_ERROR ? createErrorActorEvent(actorScope.self.id, event.data) : event);\n  });\n}\n/**\n * Sends an event to an actor.\n *\n * @param actor The `ActorRef` to send the event to.\n * @param event The event to send, or an expression that evaluates to the event\n *   to send\n * @param options Send action options\n *\n *   - `id` - The unique send event identifier (used with `cancel()`).\n *   - `delay` - The number of milliseconds to delay the sending of the event.\n */\nfunction sendTo(to, eventOrExpr, options) {\n  function sendTo(args, params) {}\n  sendTo.type = 'xsnapshot.sendTo';\n  sendTo.to = to;\n  sendTo.event = eventOrExpr;\n  sendTo.id = options?.id;\n  sendTo.delay = options?.delay;\n  sendTo.resolve = resolveSendTo;\n  sendTo.retryResolve = retryResolveSendTo;\n  sendTo.execute = executeSendTo;\n  return sendTo;\n}\n\n/**\n * Sends an event to this machine's parent.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */\nfunction sendParent(event, options) {\n  return sendTo(SpecialTargets.Parent, event, options);\n}\n/**\n * Forwards (sends) an event to the `target` actor.\n *\n * @param target The target actor to forward the event to.\n * @param options Options to pass into the send action creator.\n */\nfunction forwardTo(target, options) {\n  return sendTo(target, _ref6 => {\n    let {\n      event\n    } = _ref6;\n    return event;\n  }, options);\n}\nfunction resolveEnqueueActions(actorScope, snapshot, args, actionParams, _ref7) {\n  let {\n    collect\n  } = _ref7;\n  const actions = [];\n  const enqueue = function enqueue(action) {\n    actions.push(action);\n  };\n  enqueue.assign = function () {\n    actions.push(assign(...arguments));\n  };\n  enqueue.cancel = function () {\n    actions.push(cancel(...arguments));\n  };\n  enqueue.raise = function () {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay`\n    actions.push(raise(...arguments));\n  };\n  enqueue.sendTo = function () {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay\n    actions.push(sendTo(...arguments));\n  };\n  enqueue.sendParent = function () {\n    actions.push(sendParent(...arguments));\n  };\n  enqueue.spawnChild = function () {\n    actions.push(spawnChild(...arguments));\n  };\n  enqueue.stopChild = function () {\n    actions.push(stopChild(...arguments));\n  };\n  enqueue.emit = function () {\n    actions.push(emit(...arguments));\n  };\n  collect({\n    context: args.context,\n    event: args.event,\n    enqueue,\n    check: guard => evaluateGuard(guard, snapshot.context, args.event, snapshot),\n    self: actorScope.self,\n    system: actorScope.system\n  }, actionParams);\n  return [snapshot, undefined, actions];\n}\n/**\n * Creates an action object that will execute actions that are queued by the\n * `enqueue(action)` function.\n *\n * @example\n *\n * ```ts\n * import { createMachine, enqueueActions } from 'xstate';\n *\n * const machine = createMachine({\n *   entry: enqueueActions(({ enqueue, check }) => {\n *     enqueue.assign({ count: 0 });\n *\n *     if (check('someGuard')) {\n *       enqueue.assign({ count: 1 });\n *     }\n *\n *     enqueue('someAction');\n *   })\n * });\n * ```\n */\nfunction enqueueActions(collect) {\n  function enqueueActions(args, params) {}\n  enqueueActions.type = 'xstate.enqueueActions';\n  enqueueActions.collect = collect;\n  enqueueActions.resolve = resolveEnqueueActions;\n  return enqueueActions;\n}\nfunction resolveLog(_, snapshot, actionArgs, actionParams, _ref8) {\n  let {\n    value,\n    label\n  } = _ref8;\n  return [snapshot, {\n    value: typeof value === 'function' ? value(actionArgs, actionParams) : value,\n    label\n  }];\n}\nfunction executeLog(_ref9, _ref10) {\n  let {\n    logger\n  } = _ref9;\n  let {\n    value,\n    label\n  } = _ref10;\n  if (label) {\n    logger(label, value);\n  } else {\n    logger(value);\n  }\n}\n/**\n * @param expr The expression function to evaluate which will be logged. Takes\n *   in 2 arguments:\n *\n *   - `ctx` - the current state context\n *   - `event` - the event that caused this action to be executed.\n *\n * @param label The label to give to the logged expression.\n */\nfunction log() {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _ref11 => {\n    let {\n      context,\n      event\n    } = _ref11;\n    return {\n      context,\n      event\n    };\n  };\n  let label = arguments.length > 1 ? arguments[1] : undefined;\n  function log(args, params) {}\n  log.type = 'xstate.log';\n  log.value = value;\n  log.label = label;\n  log.resolve = resolveLog;\n  log.execute = executeLog;\n  return log;\n}\nexport { SpecialTargets as S, assign as a, enqueueActions as b, sendTo as c, emit as e, forwardTo as f, log as l, sendParent as s };","map":{"version":3,"names":["T","ProcessingStatus","z","resolveReferencedActor","A","createActor","U","cloneMachineSnapshot","V","XSTATE_ERROR","W","createErrorActorEvent","e","evaluateGuard","M","cancel","O","raise","P","spawnChild","R","stopChild","createSpawner","actorScope","_ref","event","spawnedChildren","machine","context","spawn","src","options","arguments","length","undefined","systemId","input","logic","Error","id","actorRef","parent","self","syncSnapshot","defer","_processingStatus","Stopped","start","resolveAssign","snapshot","actionArgs","actionParams","_ref2","assignment","assignArgs","system","partialUpdate","key","Object","keys","propAssignment","updatedContext","assign","children","args","params","type","resolve","resolveEmit","_","_ref3","eventOrExpr","resolvedEvent","executeEmit","_ref4","emit","execute","SpecialTargets","resolveSendTo","_ref5","extra","to","delay","delaysMap","implementations","delays","resolvedDelay","configDelay","resolvedTarget","targetActorRef","Parent","_parent","Internal","startsWith","slice","deferredActorIds","includes","retryResolveSendTo","executeSendTo","scheduler","schedule","_relay","data","sendTo","retryResolve","sendParent","forwardTo","target","_ref6","resolveEnqueueActions","_ref7","collect","actions","enqueue","action","push","check","guard","enqueueActions","resolveLog","_ref8","value","label","executeLog","_ref9","_ref10","logger","log","_ref11","S","a","b","c","f","l","s"],"sources":["/Users/evgeniy/react-player/node_modules/xstate/dist/log-15d0f775.esm.js"],"sourcesContent":["import { T as ProcessingStatus, z as resolveReferencedActor, A as createActor, U as cloneMachineSnapshot, V as XSTATE_ERROR, W as createErrorActorEvent, e as evaluateGuard, M as cancel, O as raise, P as spawnChild, R as stopChild } from './raise-0f7cf128.esm.js';\n\nfunction createSpawner(actorScope, {\n  machine,\n  context\n}, event, spawnedChildren) {\n  const spawn = (src, options = {}) => {\n    const {\n      systemId,\n      input\n    } = options;\n    if (typeof src === 'string') {\n      const logic = resolveReferencedActor(machine, src);\n      if (!logic) {\n        throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);\n      }\n      const actorRef = createActor(logic, {\n        id: options.id,\n        parent: actorScope.self,\n        syncSnapshot: options.syncSnapshot,\n        input: typeof input === 'function' ? input({\n          context,\n          event,\n          self: actorScope.self\n        }) : input,\n        src,\n        systemId\n      });\n      spawnedChildren[actorRef.id] = actorRef;\n      return actorRef;\n    } else {\n      const actorRef = createActor(src, {\n        id: options.id,\n        parent: actorScope.self,\n        syncSnapshot: options.syncSnapshot,\n        input: options.input,\n        src,\n        systemId\n      });\n      return actorRef;\n    }\n  };\n  return (src, options) => {\n    const actorRef = spawn(src, options); // TODO: fix types\n    spawnedChildren[actorRef.id] = actorRef;\n    actorScope.defer(() => {\n      if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n        return;\n      }\n      actorRef.start();\n    });\n    return actorRef;\n  };\n}\n\nfunction resolveAssign(actorScope, snapshot, actionArgs, actionParams, {\n  assignment\n}) {\n  if (!snapshot.context) {\n    throw new Error('Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.');\n  }\n  const spawnedChildren = {};\n  const assignArgs = {\n    context: snapshot.context,\n    event: actionArgs.event,\n    spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),\n    self: actorScope.self,\n    system: actorScope.system\n  };\n  let partialUpdate = {};\n  if (typeof assignment === 'function') {\n    partialUpdate = assignment(assignArgs, actionParams);\n  } else {\n    for (const key of Object.keys(assignment)) {\n      const propAssignment = assignment[key];\n      partialUpdate[key] = typeof propAssignment === 'function' ? propAssignment(assignArgs, actionParams) : propAssignment;\n    }\n  }\n  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n  return [cloneMachineSnapshot(snapshot, {\n    context: updatedContext,\n    children: Object.keys(spawnedChildren).length ? {\n      ...snapshot.children,\n      ...spawnedChildren\n    } : snapshot.children\n  })];\n}\n/**\n * Updates the current context of the machine.\n *\n * @example\n *\n * ```ts\n * import { createMachine, assign } from 'xstate';\n *\n * const countMachine = createMachine({\n *   context: {\n *     count: 0,\n *     message: ''\n *   },\n *   on: {\n *     inc: {\n *       actions: assign({\n *         count: ({ context }) => context.count + 1\n *       })\n *     },\n *     updateMessage: {\n *       actions: assign(({ context, event }) => {\n *         return {\n *           message: event.message.trim()\n *         };\n *       })\n *     }\n *   }\n * });\n * ```\n *\n * @param assignment An object that represents the partial context to update, or\n *   a function that returns an object that represents the partial context to\n *   update.\n */\nfunction assign(assignment) {\n  function assign(args, params) {\n  }\n  assign.type = 'xstate.assign';\n  assign.assignment = assignment;\n  assign.resolve = resolveAssign;\n  return assign;\n}\n\nfunction resolveEmit(_, snapshot, args, actionParams, {\n  event: eventOrExpr\n}) {\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  return [snapshot, {\n    event: resolvedEvent\n  }];\n}\nfunction executeEmit(actorScope, {\n  event\n}) {\n  actorScope.defer(() => actorScope.emit(event));\n}\n/**\n * Emits an event to event handlers registered on the actor via `actor.on(event,\n * handler)`.\n *\n * @example\n *\n * ```ts\n * import { emit } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     something: {\n *       actions: emit({\n *         type: 'emitted',\n *         some: 'data'\n *       })\n *     }\n *   }\n *   // ...\n * });\n *\n * const actor = createActor(machine).start();\n *\n * actor.on('emitted', (event) => {\n *   console.log(event);\n * });\n *\n * actor.send({ type: 'something' });\n * // logs:\n * // {\n * //   type: 'emitted',\n * //   some: 'data'\n * // }\n * ```\n */\nfunction emit(/** The event to emit, or an expression that returns an event to emit. */\neventOrExpr) {\n  function emit(args, params) {\n  }\n  emit.type = 'xstate.emit';\n  emit.event = eventOrExpr;\n  emit.resolve = resolveEmit;\n  emit.execute = executeEmit;\n  return emit;\n}\n\n/**\n * @remarks\n * `T | unknown` reduces to `unknown` and that can be problematic when it comes\n * to contextual typing. It especially is a problem when the union has a\n * function member, like here:\n *\n * ```ts\n * declare function test(\n *   cbOrVal: ((arg: number) => unknown) | unknown\n * ): void;\n * test((arg) => {}); // oops, implicit any\n * ```\n *\n * This type can be used to avoid this problem. This union represents the same\n * value space as `unknown`.\n */\n\n// https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887\n\n// @TODO: Replace with native `NoInfer` when TS issue gets fixed:\n// https://github.com/microsoft/TypeScript/pull/57673\n\n/** @deprecated Use the built-in `NoInfer` type instead */\n\n/** The full definition of an event, with a string `type`. */\n\n/**\n * The string or object representing the state value relative to the parent\n * state node.\n *\n * @remarks\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\n * - For complex state nodes, this is an object, e.g., `{ success:\n *   \"someChildState\" }`.\n */\n\n// TODO: remove once TS fixes this type-widening issue\n\n/** @deprecated Use `AnyMachineSnapshot` instead */\n\n// TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something\n/** @ignore */\n\nlet SpecialTargets = /*#__PURE__*/function (SpecialTargets) {\n  SpecialTargets[\"Parent\"] = \"#_parent\";\n  SpecialTargets[\"Internal\"] = \"#_internal\";\n  return SpecialTargets;\n}({});\n\n/** @deprecated Use `AnyActor` instead. */\n\n// Based on RxJS types\n\n// TODO: in v6, this should only accept AnyActorLogic, like ActorRefFromLogic\n\n/** @deprecated Use `Actor<T>` instead. */\n\n/**\n * Represents logic which can be used by an actor.\n *\n * @template TSnapshot - The type of the snapshot.\n * @template TEvent - The type of the event object.\n * @template TInput - The type of the input.\n * @template TSystem - The type of the actor system.\n */\n\n/** @deprecated */\n\nfunction resolveSendTo(actorScope, snapshot, args, actionParams, {\n  to,\n  event: eventOrExpr,\n  id,\n  delay\n}, extra) {\n  const delaysMap = snapshot.machine.implementations.delays;\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(`Only event objects may be used with sendTo; use sendTo({ type: \"${eventOrExpr}\" }) instead`);\n  }\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  let resolvedDelay;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay = typeof configDelay === 'function' ? configDelay(args, actionParams) : configDelay;\n  } else {\n    resolvedDelay = typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n  const resolvedTarget = typeof to === 'function' ? to(args, actionParams) : to;\n  let targetActorRef;\n  if (typeof resolvedTarget === 'string') {\n    if (resolvedTarget === SpecialTargets.Parent) {\n      targetActorRef = actorScope.self._parent;\n    } else if (resolvedTarget === SpecialTargets.Internal) {\n      targetActorRef = actorScope.self;\n    } else if (resolvedTarget.startsWith('#_')) {\n      // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor\n      // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.\n      targetActorRef = snapshot.children[resolvedTarget.slice(2)];\n    } else {\n      targetActorRef = extra.deferredActorIds?.includes(resolvedTarget) ? resolvedTarget : snapshot.children[resolvedTarget];\n    }\n    if (!targetActorRef) {\n      throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`);\n    }\n  } else {\n    targetActorRef = resolvedTarget || actorScope.self;\n  }\n  return [snapshot, {\n    to: targetActorRef,\n    event: resolvedEvent,\n    id,\n    delay: resolvedDelay\n  }];\n}\nfunction retryResolveSendTo(_, snapshot, params) {\n  if (typeof params.to === 'string') {\n    params.to = snapshot.children[params.to];\n  }\n}\nfunction executeSendTo(actorScope, params) {\n  // this forms an outgoing events queue\n  // thanks to that the recipient actors are able to read the *updated* snapshot value of the sender\n  actorScope.defer(() => {\n    const {\n      to,\n      event,\n      delay,\n      id\n    } = params;\n    if (typeof delay === 'number') {\n      actorScope.system.scheduler.schedule(actorScope.self, to, event, delay, id);\n      return;\n    }\n    actorScope.system._relay(actorScope.self,\n    // at this point, in a deferred task, it should already be mutated by retryResolveSendTo\n    // if it initially started as a string\n    to, event.type === XSTATE_ERROR ? createErrorActorEvent(actorScope.self.id, event.data) : event);\n  });\n}\n/**\n * Sends an event to an actor.\n *\n * @param actor The `ActorRef` to send the event to.\n * @param event The event to send, or an expression that evaluates to the event\n *   to send\n * @param options Send action options\n *\n *   - `id` - The unique send event identifier (used with `cancel()`).\n *   - `delay` - The number of milliseconds to delay the sending of the event.\n */\nfunction sendTo(to, eventOrExpr, options) {\n  function sendTo(args, params) {\n  }\n  sendTo.type = 'xsnapshot.sendTo';\n  sendTo.to = to;\n  sendTo.event = eventOrExpr;\n  sendTo.id = options?.id;\n  sendTo.delay = options?.delay;\n  sendTo.resolve = resolveSendTo;\n  sendTo.retryResolve = retryResolveSendTo;\n  sendTo.execute = executeSendTo;\n  return sendTo;\n}\n\n/**\n * Sends an event to this machine's parent.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */\nfunction sendParent(event, options) {\n  return sendTo(SpecialTargets.Parent, event, options);\n}\n/**\n * Forwards (sends) an event to the `target` actor.\n *\n * @param target The target actor to forward the event to.\n * @param options Options to pass into the send action creator.\n */\nfunction forwardTo(target, options) {\n  return sendTo(target, ({\n    event\n  }) => event, options);\n}\n\nfunction resolveEnqueueActions(actorScope, snapshot, args, actionParams, {\n  collect\n}) {\n  const actions = [];\n  const enqueue = function enqueue(action) {\n    actions.push(action);\n  };\n  enqueue.assign = (...args) => {\n    actions.push(assign(...args));\n  };\n  enqueue.cancel = (...args) => {\n    actions.push(cancel(...args));\n  };\n  enqueue.raise = (...args) => {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay`\n    actions.push(raise(...args));\n  };\n  enqueue.sendTo = (...args) => {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay\n    actions.push(sendTo(...args));\n  };\n  enqueue.sendParent = (...args) => {\n    actions.push(sendParent(...args));\n  };\n  enqueue.spawnChild = (...args) => {\n    actions.push(spawnChild(...args));\n  };\n  enqueue.stopChild = (...args) => {\n    actions.push(stopChild(...args));\n  };\n  enqueue.emit = (...args) => {\n    actions.push(emit(...args));\n  };\n  collect({\n    context: args.context,\n    event: args.event,\n    enqueue,\n    check: guard => evaluateGuard(guard, snapshot.context, args.event, snapshot),\n    self: actorScope.self,\n    system: actorScope.system\n  }, actionParams);\n  return [snapshot, undefined, actions];\n}\n/**\n * Creates an action object that will execute actions that are queued by the\n * `enqueue(action)` function.\n *\n * @example\n *\n * ```ts\n * import { createMachine, enqueueActions } from 'xstate';\n *\n * const machine = createMachine({\n *   entry: enqueueActions(({ enqueue, check }) => {\n *     enqueue.assign({ count: 0 });\n *\n *     if (check('someGuard')) {\n *       enqueue.assign({ count: 1 });\n *     }\n *\n *     enqueue('someAction');\n *   })\n * });\n * ```\n */\nfunction enqueueActions(collect) {\n  function enqueueActions(args, params) {\n  }\n  enqueueActions.type = 'xstate.enqueueActions';\n  enqueueActions.collect = collect;\n  enqueueActions.resolve = resolveEnqueueActions;\n  return enqueueActions;\n}\n\nfunction resolveLog(_, snapshot, actionArgs, actionParams, {\n  value,\n  label\n}) {\n  return [snapshot, {\n    value: typeof value === 'function' ? value(actionArgs, actionParams) : value,\n    label\n  }];\n}\nfunction executeLog({\n  logger\n}, {\n  value,\n  label\n}) {\n  if (label) {\n    logger(label, value);\n  } else {\n    logger(value);\n  }\n}\n/**\n * @param expr The expression function to evaluate which will be logged. Takes\n *   in 2 arguments:\n *\n *   - `ctx` - the current state context\n *   - `event` - the event that caused this action to be executed.\n *\n * @param label The label to give to the logged expression.\n */\nfunction log(value = ({\n  context,\n  event\n}) => ({\n  context,\n  event\n}), label) {\n  function log(args, params) {\n  }\n  log.type = 'xstate.log';\n  log.value = value;\n  log.label = label;\n  log.resolve = resolveLog;\n  log.execute = executeLog;\n  return log;\n}\n\nexport { SpecialTargets as S, assign as a, enqueueActions as b, sendTo as c, emit as e, forwardTo as f, log as l, sendParent as s };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}